import { DelimKind, rs, NodeType, TK, PRCD } from 'jinx-rust';
import { start, end, insertNodes, is_BlockCommentKind, is_Snippet, is_Program, each_childNode, is_ExpressionStatement, is_FlowControlExpression, is_ReassignmentNode, reassignNodeProperty, is_ClosureFunctionExpression, is_BlockExpression, is_ExpressionWithBodyOrCases, is_IfBlockExpression, transferAttributes, hasTypeBounds, is_TypeDynBounds, is_TypeImplBounds, unsafe_set_nodeType, is_TypeTraitBound, is_TypeBoundsStandaloneNode, hasAttributes, is_DocCommentAttribute, insertNode, getBodyOrCases, deleteAttributes, is_NodeWithBodyOrCases, is_AttributeOrDocComment, ownStart, is_Attribute, is_StructLiteralProperty, is_Comment, is_MissingNode, is_PunctuationToken, is_MacroInvocation, is_CallExpression, getMacroName, hasMethod, includesTK, is_BareTypeTraitBound, getNodeChildren, is_NodeWithBodyNoBody, is_StructLiteralPropertySpread, nisAnyOf, hasOuterAttributes, is_FunctionDeclaration, is_StatementNode, is_FunctionNode, getLastParameter, is_MacroRule, is_LocArray, is_LineCommentNode, is_BlockCommentNode, is_UnionPattern, is_ExpressionAsTypeCast, is_FlowControlMaybeValueExpression, is_ExpressionWithBodyOrCases_or_BlockLikeMacroInvocation, is_MemberExpression, is_ElseBlock, is_NodeWithMaybePatternNoUnionBody, is_UnaryExpression, is_ReturnExpression, is_YieldExpression, can_have_OuterAttributes, is_Identifier, is_Literal, is_LiteralNumberLike, is_StructLiteral, is_ParenthesizedNode, is_RangeLiteral, is_LogicalExpression, is_PostfixExpression, is_OperationExpression, is_ComparisonExpression, is_LetScrutinee, is_TypeFunctionNode, is_UnaryType, is_PatternVariableDeclaration, is_BitwiseOperator, is_EqualityOperator, getPrecedence, is_multiplicativeOperator, is_bitshiftOperator, getAstPath, is_MatchExpressionCase, is_EnumMemberDeclaration, is_StructPropertyDeclaration, is_StructPatternProperty, is_LineCommentKind, is_CommentOrDocComment, is_ExternSpecifier, hasSuffix, getDelimChars, is_ArrayOrTupleLiteral, is_Node, is_MatchExpression, is_SourceFile, is_MacroGroup, is_DelimGroup, is_MacroParameterDeclaration, is_MacroInlineRuleDeclaration, is_ExpressionPath, is_ReassignmentExpression, is_GenericParameterDeclaration, is_TypeCallNamedArgument, is_VariableDeclarationNode, is_LiteralStringLike, is_UnwrapExpression, is_IdentifierOrIndex, is_ExpressionTypeCast, hasSemiNoBody, is_OrExpression, is_ImplDeclarationNode, is_TupleStructDeclaration, hasParameters, hasSelfParameter, is_ClosureBlock, hasCondition, is_TupleNode, hasProperties, hasItems, is_TupleLiteral, is_TuplePattern, is_RangePattern, is_RestPattern, is_TypeTuple, hasSemiNoProperties, is_StructPattern, is_UnionDeclaration, is_StructDeclaration, is_EnumMemberStructDeclaration, getParameters, is_FunctionParameterDeclaration, isInner, is_FunctionSpread, isTK, hasLetScrutineeCondition, is_ImplicitReturnAbleNode, is_ExpressionWithBody, is_ForInBlockExpression, is_LoopBlockExpression, is_WhileBlockExpression, hasBody, is_MinusExpression, is_StructPatternPropertyDestructured, is_StructProperty, is_LiteralBooleanLike, getOwnChildAstPath } from 'jinx-rust/utils';
import doc from 'prettier/doc.js';

// src/format/plugin.ts

// src/utils/debug.ts
var cwd = typeof process === "object" && typeof (process == null ? void 0 : process.cwd) === "function" ? /* @__PURE__ */ normPath(/* @__PURE__ */ process.cwd() ?? "") : "";
function normPath_strip_cwd(filepath) {
  let normFilePath = normPath(filepath);
  return normFilePath.startsWith(cwd) ? normFilePath.slice(cwd.length + 1) : normFilePath;
}
var StackLine = class {
  constructor(raw) {
    ({
      1: this.callee = "",
      2: this.filepath = "",
      3: this.line = "",
      4: this.col = "",
      5: this.other = ""
    } = (this.raw = raw).match(/at (?:(.+?)\s+\()?(?:(.+?):([0-9]+)(?::([0-9]+))?|([^)]+))\)?/) ?? ["", "", "", "", "", ""]);
    this.url = this.filepath ? normPath_strip_cwd(this.filepath) + (this.line && this.col && `:${this.line}:${this.col}`) : this.other === "native" ? "<native>" : "";
  }
};
function getPrintWidth() {
  return clamp(0, getTerminalWidth(128), 200) - 4;
}
var StackItem = class extends StackLine {
  constructor(stack, i, raw) {
    super(raw);
    this.stack = stack;
    this.i = i;
    this.hidden = false;
  }
  hide() {
    this.hidden = true;
    return this;
  }
  hideNext(n) {
    var _a;
    for (let i = 0; i < n; i++)
      (_a = this.at(i)) == null ? void 0 : _a.hide();
  }
  hideWhileTrue(test) {
    let line2 = this;
    while (line2 && test(line2))
      line2 = line2.hide().next();
  }
  at(relIndex) {
    return this.i + relIndex >= this.stack.length || this.i + relIndex < 0 ? void 0 : this.stack[this.i + relIndex];
  }
  next() {
    return this.at(1);
  }
  toString() {
    var _a, _b, _c, _d;
    const url = this.url;
    const calleeColor = ((_b = (_a = this.stack.style) == null ? void 0 : _a.callee) == null ? void 0 : _b.call(_a, this.callee, this)) ?? color.cyan;
    const urlColor = ((_d = (_c = this.stack.style) == null ? void 0 : _c.url) == null ? void 0 : _d.call(_c, url, this)) ?? color.grey;
    return compose2Cols("    at " + calleeColor(this.callee), urlColor(url), getPrintWidth());
  }
};
function createStack(message, Error_stack, style) {
  for (var STACK = [], i = 0, stack = Error_stack.split("\n").slice(2); i < stack.length; i++)
    STACK[i] = new StackItem(STACK, i, stack[i]);
  return STACK.message = message, STACK.style = style, STACK;
}
function composeStack(stack) {
  var hidden = 0;
  var str = stack.message;
  for (var item of stack)
    item.hidden ? ++hidden : str += "\n" + item.toString();
  return str + (hidden > 0 ? "\n" + color.grey(compose2Cols("", `...filtered ${hidden} lines`, getPrintWidth())) : "");
}
function createCustomError({
  message = "Unknown Error",
  editStack = (stack) => {
  },
  style = void 0,
  stackTraceLimit = 20
}) {
  const _stackTraceLimit = Error.stackTraceLimit;
  const _prepareStackTrace = Error.prepareStackTrace;
  Error.stackTraceLimit = stackTraceLimit;
  const _ctx = {};
  Error.captureStackTrace(_ctx, createCustomError);
  const stack = createStack(message, _ctx.stack, style);
  Error.prepareStackTrace = function(err2, calls) {
    editStack(stack);
    return composeStack(stack);
  };
  const err = new Error(message);
  err.stack = err.stack;
  Error.stackTraceLimit = _stackTraceLimit;
  Error.prepareStackTrace = _prepareStackTrace;
  return err;
}
function compose2Cols(left, right, len = 64, min = 1) {
  return left + " ".repeat(clamp(min, len, len - (color.unstyledLength(left) + color.unstyledLength(right)))) + right;
}
function exit(message, ...ctx2) {
  if (ctx2.length > 0)
    console.log("Error context:", { ...ctx2 });
  throw createCustomError({ message });
}
exit.never = function never(...ctx2) {
  exit("Reached unreachable code", ...ctx2);
};
function assert(predicate, err, ...ctx2) {
  if (false === predicate)
    exit(err ?? "Assertion failed", ...ctx2);
}
function Identity(v) {
  return v;
}
function last_of(arr) {
  return arr[arr.length - 1];
}
function normPath(filepath) {
  return filepath.replace(/^file:\/\/\//, "").replace(/\\\\?/g, "/");
}
function binarySearchIn(array, target, toValue) {
  if (isEmpty(array))
    return -1;
  let i = 0;
  let low = 0;
  let high = array.length - 1;
  let value = toValue(array[high]);
  if (target >= value)
    return high;
  else
    high--;
  while (low <= high) {
    i = low + (high - low >> 1);
    value = toValue(array[i]);
    if (target === value)
      return i;
    if (target > value)
      low = i + 1;
    else
      high = i - 1;
  }
  return low - 1;
}
function getTerminalWidth(fallbackWidth = 200) {
  var _a, _b;
  return ((_b = (_a = globalThis == null ? void 0 : globalThis.process) == null ? void 0 : _a.stdout) == null ? void 0 : _b.columns) ?? fallbackWidth;
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var color = ((cfn, mfn) => ({
  black: cfn(30),
  red: cfn(31),
  green: cfn(32),
  yellow: cfn(33),
  blue: cfn(34),
  magenta: cfn(35),
  cyan: cfn(36),
  white: cfn(37),
  grey: cfn(90),
  bold: mfn(1, 22),
  italic: mfn(3, 23),
  underline: mfn(4, 24),
  hidden: mfn(8, 28),
  hiddenCursor: (str) => `\x1B[?25l${str}\x1B[?25h`,
  unstyle: (str) => str.replace(/\x1B\[[0-9][0-9]?m/g, ""),
  unstyledLength: (str) => str.replace(/\x1B\[[0-9][0-9]?m/g, "").length,
  link: (str) => color.underline(color.blue(str))
}))(
  (c1) => isBrowser ? Identity : (str) => `\x1B[${c1}m${str.replace(/\x1B\[39m/g, `\x1B[${c1}m`)}\x1B[39m`,
  (c1, c2) => isBrowser ? Identity : (str) => `\x1B[${c1}m${str}\x1B[${c2}m`
);
function Map_get(map, key, init) {
  if (!map.has(key))
    map.set(key, init(key));
  return map.get(key);
}
function isEmpty(array) {
  return 0 === array.length;
}
function Array_splice(array, target, index = array.indexOf(target)) {
  array.splice(index, 1);
}
function Array_replace(array, target, ...replacements) {
  array.indexOf(target);
  array.splice(array.indexOf(target), 1, ...replacements);
}
function has_key_defined(o, k) {
  return k in o && void 0 !== o[k];
}
function is_array(data) {
  return Array.isArray(data);
}
function each(data, callback) {
  switch (data.constructor) {
    case Array: {
      let i = 0;
      for (; i < data.length; i++)
        callback(data[i], i);
      return;
    }
    case Object: {
      let k;
      for (k in data)
        callback(data[k], k);
      return;
    }
    case Set: {
      let d;
      for (d of data)
        callback(d, void 0);
      return;
    }
    case Map: {
      let e;
      for (e of data)
        callback(e[1], e[0]);
      return;
    }
    default: {
      let x;
      for (x of data)
        callback(x, void 0);
      return;
    }
  }
}
function iLast(index, array) {
  return 1 + index === array.length;
}
function try_eval(fn) {
  try {
    return fn();
  } catch (e) {
    return void 0;
  }
}
function clamp(min, max, value) {
  return value > min ? value < max ? value : max : min;
}
function flat(arr) {
  return arr.flat(Infinity);
}
function map_tagged_template(args, map) {
  const arr = [args[0][0]];
  for (var i = 1; i < args.length; i++)
    arr.push(map(args[i]), args[0][i]);
  return arr;
}
function spliceAll(array) {
  const r = [...array];
  array.length = 0;
  return r;
}
function spread(fn) {
  return [...fn()];
}
var {
  join,
  line,
  softline,
  hardline,
  literalline,
  group,
  conditionalGroup,
  fill,
  lineSuffix,
  lineSuffixBoundary,
  cursor,
  breakParent,
  ifBreak,
  trim,
  indent,
  indentIfBreak,
  align,
  addAlignmentToDoc,
  markAsRoot,
  dedentToRoot,
  dedent,
  hardlineWithoutBreakParent,
  literallineWithoutBreakParent,
  label
} = doc.builders;
var {
  isConcat,
  getDocParts,
  willBreak,
  traverseDoc,
  findInDoc,
  mapDoc,
  propagateBreaks,
  removeLines,
  stripTrailingHardline,
  normalizeParts,
  normalizeDoc,
  cleanDoc,
  canBreak
} = doc.utils;
var Symbol_comments = Symbol.for("comments");
var DCM = /* @__PURE__ */ ((DCM2) => {
  DCM2["arguments"] = "arguments";
  DCM2["parameters"] = "parameters";
  DCM2["items"] = "items";
  DCM2["properties"] = "properties";
  DCM2["members"] = "members";
  DCM2["body"] = "body";
  DCM2["cases"] = "cases";
  DCM2["typeArguments"] = "typeArguments";
  DCM2["ltParameters"] = "ltParameters";
  DCM2["generics"] = "generics";
  DCM2["specifiers"] = "specifiers";
  DCM2["rules"] = "rules";
  DCM2["match"] = "match";
  DCM2["transform"] = "transform";
  DCM2["segments"] = "segments";
  return DCM2;
})(DCM || {});

// src/format/complexity.ts
var DEPTH = 0;
var ANCESTRY = [];
var LONE_SHORT_ARGUMENT_THRESHOLD_RATE = 0.25;
function withCheckContext(fn) {
  if (0 === DEPTH) {
    return fn();
  } else {
    DEPTH = 0;
    const prev = spliceAll(ANCESTRY);
    try {
      return fn();
    } finally {
      DEPTH = ANCESTRY.push(...prev);
    }
  }
}
function is_short(str) {
  return str.length <= LONE_SHORT_ARGUMENT_THRESHOLD_RATE * getOptions().printWidth;
}
function print(target) {
  const current = getNode();
  const keys = [...getAstPath(ANCESTRY[0], getNode())];
  for (let i = 1; i < ANCESTRY.length; i++)
    keys.push(...getOwnChildAstPath(ANCESTRY[i - 1], ANCESTRY[i]));
  keys.push(...getOwnChildAstPath(last_of(ANCESTRY), target));
  try {
    return getContext().path.call(() => getPrintFn()(), ...keys);
  } catch (e) {
    console.log({ current, target, keys, ANCESTRY });
    throw e;
  }
}
function IsSimpleFunction(fn) {
  return function(node) {
    if (0 !== DEPTH && node === ANCESTRY[DEPTH - 1]) {
      return fn(node);
    }
    if (DEPTH >= 2) {
      return isShortBasic(node);
    }
    try {
      return fn(ANCESTRY[DEPTH++] = node);
    } finally {
      ANCESTRY.length = --DEPTH;
    }
  };
}
function HasComplexFunction(fn) {
  return function(node) {
    if (0 !== DEPTH && node === ANCESTRY[DEPTH - 1]) {
      return fn(node);
    }
    if (DEPTH >= 2) {
      return !isShortBasic(node);
    }
    try {
      return fn(ANCESTRY[DEPTH++] = node);
    } finally {
      ANCESTRY.length = --DEPTH;
    }
  };
}
var isShortBasic = (node) => {
  switch (node.nodeType) {
    case NodeType.MissingNode:
      return true;
    case NodeType.Identifier:
    case NodeType.Index:
    case NodeType.LtIdentifier:
    case NodeType.LbIdentifier:
    case NodeType.McIdentifier:
      return is_short(node.name);
    case NodeType.Literal:
      return is_short(node.value) && !/\n/.test(node.value);
  }
  return false;
};
var isSimpleType = IsSimpleFunction((node) => {
  switch (node.nodeType) {
    case NodeType.MissingNode:
    case NodeType.FunctionSpread:
      return true;
    case NodeType.MacroInvocation:
      return false;
    case NodeType.Identifier:
    case NodeType.TypeNever:
    case NodeType.TypeInferred:
      return true;
    case NodeType.TypePath:
      return isShortBasic(node.segment) && (!node.namespace || isSimpleType(node.namespace));
    case NodeType.TypeCall:
      return isSimpleType(node.typeCallee) && !hasComplexTypeArguments(node);
    case NodeType.ExpressionTypeSelector:
      return isSimpleType(node.typeTarget) && (!node.typeExpression || isSimpleType(node.typeExpression));
    case NodeType.TypeDynBounds:
      return !hasComplexTypeBounds(node);
    case NodeType.TypeImplBounds:
      return !hasComplexTypeBounds(node);
    case NodeType.TypeFnPointer: {
      const param = node.parameters[0];
      return (!node.extern || !node.extern.abi || isShortBasic(node.extern.abi)) && !hasComplexLtParameters(node) && (node.parameters.length === 0 || node.parameters.length === 1 && (is_FunctionSpread(param) || !is_TypeFunctionNode(param.typeAnnotation) && isSimpleType(param.typeAnnotation))) && (!node.returnType || isSimpleType(node.returnType));
    }
    case NodeType.TypeFunction:
      return isSimpleType(node.callee) && node.parameters.every(isSimpleType) && (!node.returnType || isSimpleType(node.returnType));
    case NodeType.TypeSizedArray:
      return isSimpleType(node.typeExpression) && isShortBasic(node.sizeExpression);
    case NodeType.TypeSlice:
      return isSimpleType(node.typeExpression);
    case NodeType.TypeTuple:
      return node.items.length === 0 || node.items.length === 1 && isSimpleType(node.items[0]);
    case NodeType.TypeReference:
    case NodeType.TypeDereferenceMut:
    case NodeType.TypeDereferenceConst:
    case NodeType.TypeParenthesized:
      return isSimpleType(node.typeExpression);
    default:
      return false;
  }
});
var hasComplexTypeBounds = HasComplexFunction((node) => {
  return !!node.typeBounds && node.typeBounds.length > 1 && !node.typeBounds.every(isSimpleTypeBound);
});
var isSimpleTypeBound = (node) => {
  switch (node.nodeType) {
    case NodeType.TypeParenthesized:
      return isSimpleTypeBound(node.typeExpression);
    case NodeType.LtIdentifier:
    case NodeType.LtElided:
    case NodeType.LtStatic:
      return true;
    case NodeType.TypeTraitBound:
      return is_BareTypeTraitBound(node) && isSimpleTypeNamespaceTargetNoSelector(node.typeExpression);
    default:
      return false;
  }
  function isSimpleTypeNamespaceTargetNoSelector(node2) {
    switch (node2.nodeType) {
      case NodeType.Identifier:
        return true;
      case NodeType.TypePath:
        return void 0 === node2.namespace || isSimpleTypeNamespaceTargetNoSelector(node2.namespace);
      case NodeType.TypeCall:
        return false;
      case NodeType.TypeFunction:
        return isSimpleTypeNamespaceTargetNoSelector(node2.callee) && node2.parameters.length === 0 && !node2.returnType;
      default:
        return false;
    }
  }
};
var hasComplexTypeArguments = HasComplexFunction(
  (node) => !node.typeArguments || node.typeArguments.length === 0 ? false : node.typeArguments.length === 1 ? (() => {
    const arg = node.typeArguments[0];
    return is_TypeBoundsStandaloneNode(arg) || canBreak(print(arg));
  })() : true
);
var hasComplexLtParameters = HasComplexFunction((node) => {
  const ltParameters = node.ltParameters;
  if (!ltParameters || ltParameters.length === 0) {
    return false;
  }
  if (ltParameters.length === 1) {
    const arg = ltParameters[0];
    if (arg.ltBounds && arg.ltBounds.length > 1) {
      return true;
    }
    return false;
  }
  return true;
});
var isShortGenericParameterDeclaration = IsSimpleFunction((node) => {
  switch (node.nodeType) {
    case NodeType.GenericTypeParameterDeclaration:
      return !node.typeBounds && !node.typeDefault;
    case NodeType.ConstTypeParameterDeclaration:
      return (!node.typeAnnotation || is_MissingNode(node)) && !node.typeDefault;
    case NodeType.GenericLtParameterDeclaration:
      return !node.ltBounds;
    default:
      exit.never();
  }
});
var hasComplexGenerics = HasComplexFunction((node) => {
  return has_key_defined(node, "generics") && node.generics.length > 0 && !node.generics.every(isShortGenericParameterDeclaration);
});
var hasComplexTypeAnnotation = HasComplexFunction((node) => {
  if (is_VariableDeclarationNode(node) && !is_LetScrutinee(node)) {
    const { typeAnnotation } = node;
    return !!typeAnnotation && !is_MissingNode(typeAnnotation) && !isSimpleType(typeAnnotation);
  } else {
    return false;
  }
});
function isIdent(node, name) {
  return !!node && is_Identifier(node) && node.name === name;
}
function isToken(node, tk) {
  return !!node && isTK(node, tk);
}
function isGroup(node, dk) {
  return !!node && is_DelimGroup(node) && node.segments.dk === dk;
}

// src/format/macros/cfg_if.ts
function transform_macro_cfg_if(segments) {
  const danglingAttributes = [];
  const comments = [];
  const block = function create_if_block(i) {
    if (i >= segments.length)
      return void 0;
    const _if = segments[i];
    const pound = segments[i + 1];
    const grp = segments[i + 2];
    const block2 = segments[i + 3];
    const _else = segments[i + 4];
    assert(
      isIdent(_if, "if") && isToken(pound, TK["#"]) && isGroup(grp, DelimKind["[]"]) && isGroup(block2, DelimKind["{}"]) && (!_else || isIdent(_else, "else"))
    );
    return create_block(
      block2,
      (body) => rs.mockNode(NodeType.IfBlockExpression, block2.loc.cloneFrom(start(_if)), {
        label: void 0,
        condition: rs.mockNode(NodeType.Attribute, grp.loc.cloneFrom(start(pound)), {
          segments: grp.segments,
          value: grp.segments.loc.sliceText(),
          line: false,
          inner: false
        }),
        body,
        else: (_else && iLast(i + 5, segments) ? function create_else_block(i2) {
          const block3 = segments[i2];
          assert(isGroup(block3, DelimKind["{}"]));
          return create_block(
            block3,
            (body2) => rs.mockNode(NodeType.BlockExpression, body2.loc.clone(), {
              label: void 0,
              body: body2
            })
          );
        } : create_if_block)(i + 5)
      })
    );
  }(0);
  const ast = rs.createLocArray(
    segments.dk,
    segments.loc,
    block && [
      rs.mockNode(NodeType.ExpressionStatement, block.loc.clone(), {
        expression: block,
        semi: false
      })
    ]
  );
  return rs.mockNode(NodeType.Snippet, segments.loc.clone(), { ast, danglingAttributes, comments });
  function create_block(group2, fn) {
    const snippet = rs.toBlockBody(group2.segments);
    insertNodes(danglingAttributes, snippet.danglingAttributes);
    insertNodes(comments, snippet.comments);
    const block2 = fn(snippet.ast);
    transferAttributes(snippet, block2);
    return block2;
  }
}

// src/format/transform.ts
function is_CallLikeMacroInvocation(node) {
  return is_MacroInvocation(node) && "arguments" in node;
}
function is_BlockLikeMacroInvocation(node) {
  return is_MacroInvocation(node) && "body" in node;
}
function is_CallExpression_or_CallLikeMacroInvocation(node) {
  return is_CallExpression(node) || is_CallLikeMacroInvocation(node);
}
var IGNORED_MACROS = /* @__PURE__ */ new Set([
  "quote"
]);
var HARDCODED_MACRO_DELIMS = /* @__PURE__ */ new Map();
each(
  {
    [DelimKind["{}"]]: [
      "thread_local",
      "cfg_if"
    ],
    [DelimKind["()"]]: [
      "assert_eq",
      "assert_ne",
      "assert",
      "cfg",
      "concat_bytes",
      "concat_idents",
      "concat",
      "debug_assert_eq",
      "debug_assert_ne",
      "debug_assert",
      "eprint",
      "eprintln",
      "format_args_nl",
      "format_args",
      "format",
      "matches",
      "panic",
      "print",
      "println",
      "try",
      "unimplemented",
      "unreachable",
      "write",
      "writeln"
    ],
    [DelimKind["[]"]]: [
      "vec"
    ]
  },
  (names, tk) => each(names, (name) => {
    HARDCODED_MACRO_DELIMS.set(name, +tk);
  })
);
var _COMMENTS = void 0;
var _DANGLING_ATTRIBUTES = void 0;
function transform_ast(options2) {
  try {
    _COMMENTS = options2.comments;
    _DANGLING_ATTRIBUTES = options2.danglingAttributes;
    transformNode(options2.rsParsedFile);
  } finally {
    _depth = 0;
    _COMMENTS = void 0;
    _DANGLING_ATTRIBUTES = void 0;
  }
}
var _depth = 0;
var isReadingSnippet = () => 0 !== _depth;
function maybe_transform_node(node, read_snippet, fn) {
  const snippet = try_eval(read_snippet);
  if (snippet) {
    ++_depth;
    transformNode(snippet);
    --_depth;
    fn(node, snippet);
    transformed.add(node);
    return node;
  }
}
var transformed = /* @__PURE__ */ new WeakSet();
function isTransformed(node) {
  return transformed.has(node);
}
var transform = {
  [NodeType.Attribute](node) {
    maybe_transform_node(
      node,
      () => rs.toCallExpressionArguments(node.segments),
      (node2, snippet) => {
        node2.segments = snippet.ast;
      }
    );
  },
  [NodeType.MacroInlineRuleDeclaration](node) {
    node.match.dk = DelimKind["()"];
    node.transform.dk = DelimKind["{}"];
  },
  [NodeType.MacroInvocation](node) {
    const name = getMacroName(node);
    if (IGNORED_MACROS.has(name) || node.segments.length === 0 || node.segments.length === 1 && is_PunctuationToken(node.segments[0])) {
      return;
    }
    const tk = transformMacroDelim(name, node);
    if (name === "cfg_if") {
      transformBlockLike(() => transform_macro_cfg_if(node.segments));
    } else if (tk === DelimKind["{}"]) {
      transformBlockLike();
    } else {
      transformCallLike();
    }
    function transformBlockLike(transform2 = () => rs.toBlockBody(node.segments)) {
      return maybe_transform_node(node, transform2, (node2, snippet) => {
        const _body = snippet.ast;
        _body.dk = tk;
        node2.body = _body;
        node2.segments = _body;
        transferAttributes(snippet, node2);
      });
    }
    function transformCallLike() {
      return maybe_transform_node(
        node,
        () => rs.toCallExpressionArguments(node.segments),
        (node2, snippet) => {
          const _arguments = snippet.ast;
          _arguments.dk = tk;
          node2.method = void 0;
          node2.typeArguments = void 0;
          node2.arguments = _arguments;
          node2.segments = _arguments;
        }
      );
    }
  },
  [NodeType.CallExpression](node) {
    if (hasMethod(node)) {
      node.callee = rs.mockNode(NodeType.MemberExpression, node.method.loc.cloneFrom(start(node.callee)), {
        expression: node.callee,
        property: node.method,
        computed: false
      });
      node.method = void 0;
      getOptions().actuallyMethodNodes.add(node.callee);
    }
  },
  [NodeType.AutoTraitDeclaration](node) {
    mockBodyNoBody(node);
  },
  [NodeType.NegativeImplDeclaration](node) {
    mockBodyNoBody(node);
  },
  [NodeType.StructLiteral](node) {
    moveSpreadsToEnd(node);
  },
  [NodeType.StructPattern](node) {
    moveSpreadsToEnd(node);
  }
};
function moveSpreadsToEnd(node) {
  const props = node.properties;
  if (props.some((p, i, a) => is_StructSpread(p) && !iLast(i, a))) {
    const spreads = [];
    for (let i = 0; i < props.length; i++) {
      const prop = props[i];
      if (is_StructSpread(prop)) {
        Array_splice(props, prop, i--);
        spreads.push(prop);
      }
    }
    props.push(...spreads);
  }
}
function mockBodyNoBody(node) {
  node.body = rs.createLocArray(last_of(rs.toTokens(node).ast).loc.clone(), DelimKind["{}"]);
}
function transformMacroDelim(name, node) {
  if (HARDCODED_MACRO_DELIMS.has(name)) {
    return HARDCODED_MACRO_DELIMS.get(name);
  }
  if (node.segments.dk === DelimKind["{}"] && includesTK(node, TK[","])) {
    return DelimKind["()"];
  }
  if (node.segments.dk === DelimKind["()"] && includesTK(node, TK[";"])) {
    return DelimKind["{}"];
  }
  return node.segments.dk;
}
var seen = /* @__PURE__ */ new WeakSet();
function transformNode(node, parent, key, index) {
  var _a;
  if (!seen.has(node)) {
    seen.add(node);
    if (is_Snippet(node) || is_Program(node)) {
      registerPogramLike(node);
    }
    each_childNode(node, transformNode);
    insert_blocks(node, parent, key, index);
    (_a = transform[node.nodeType]) == null ? void 0 : _a.call(transform, node);
    flatten_typeBounds(node);
    transform_nodeAttributes(node);
  }
  return node;
}
function insert_blocks(node, parent, key, index) {
  if (parent && key) {
    if (!is_ExpressionStatement(parent) && (is_FlowControlExpression(node) || !isReadingSnippet() && is_ReassignmentNode(node) && !(is_ReassignmentNode(parent) && parent.left === node))) {
      reassignNodeProperty(blockify(node), parent, key, index);
    } else if (is_ClosureFunctionExpression(node) && (!!node.returnType && !is_BlockExpression(node.expression) || is_ExpressionWithBodyOrCases(node.expression) && !is_BlockExpression(node.expression) && !is_IfBlockExpression(node.expression))) {
      node.expression = blockify(node.expression);
    }
  }
  function blockify(node2) {
    const block = rs.mockNode(NodeType.BlockExpression, node2.loc.clone(), {
      label: void 0,
      body: rs.createLocArray(DelimKind["{}"], node2.loc.clone(), [
        rs.mockNode(NodeType.ExpressionStatement, node2.loc.clone(), { semi: false, expression: node2 })
      ])
    });
    transferAttributes(node2, block);
    return block;
  }
}
function flatten_typeBounds(topNode) {
  if (hasTypeBounds(topNode)) {
    const nestedBounds = topNode.typeBounds.filter(isBoundWithNestedBounds);
    const [first, ...subsequent] = nestedBounds;
    const flatten = (bound) => Array_replace(topNode.typeBounds, bound, ...bound.typeExpression.typeBounds);
    if (nestedBounds.every(isBareBoundWithNestedBoundsNoPrefix)) {
      each(nestedBounds, flatten);
    } else if (!hasDefinedPrefix(topNode) && first === topNode.typeBounds[0] && !isBareBoundWithNestedBoundsNoPrefix(first) && subsequent.every(isBareBoundWithNestedBoundsNoPrefix)) {
      if (is_TypeDynBounds(topNode)) {
        if (is_TypeImplBounds(first.typeExpression)) {
          unsafe_set_nodeType(topNode, NodeType.TypeImplBounds);
        } else {
          topNode.dyn = true;
        }
        each(nestedBounds, flatten);
      } else {
        each(subsequent, flatten);
        first.typeExpression.typeBounds.push(...topNode.typeBounds.slice(1));
        topNode.typeBounds.length = 1;
      }
    }
  }
  function isBoundWithNestedBounds(bound) {
    return is_TypeTraitBound(bound) && is_TypeBoundsStandaloneNode(bound.typeExpression);
  }
  function isBareBoundWithNestedBounds(bound) {
    return isBoundWithNestedBounds(bound) && is_BareTypeTraitBound(bound);
  }
  function isBareBoundWithNestedBoundsNoPrefix(bound) {
    return isBareBoundWithNestedBounds(bound) && !hasDefinedPrefix(bound.typeExpression);
  }
  function hasDefinedPrefix(node) {
    return is_TypeDynBounds(node) && node.dyn || is_TypeImplBounds(node);
  }
}
function transform_nodeAttributes(node) {
  if (hasAttributes(node)) {
    const attrs = node.attributes;
    for (let i = 0; i < attrs.length; i++) {
      const attr = attrs[i];
      if (isReadingSnippet() && is_DocCommentAttribute(attr)) {
        const index = binarySearchIn(_COMMENTS, start(attr), start);
        _COMMENTS.splice(index, 1);
      }
      if (attr.inner) {
        if (isPrettierIgnoreAttribute(attr)) {
          setPrettierIgnoreTarget(is_Program(node) ? node.loc.src : node, attr);
        }
        insertNode(is_Snippet(node) ? node.ast : getBodyOrCases(node), attr);
        Array_splice(attrs, attr, i--);
      }
    }
    if (attrs.length === 0) {
      deleteAttributes(node);
    }
  }
}
function registerPogramLike(program) {
  const comments = spliceAll(program.comments);
  const danglingAttributes = spliceAll(program.danglingAttributes);
  for (let i = 0; i < danglingAttributes.length; i++) {
    const attr = danglingAttributes[i];
    if (is_DocCommentAttribute(attr)) {
      if (isReadingSnippet()) {
        const index = binarySearchIn(_COMMENTS, start(attr), start);
        _COMMENTS.splice(index, 1);
      }
    } else {
      transformNode(danglingAttributes[i], program, "danglingAttributes", i);
    }
  }
  if (!isReadingSnippet())
    insertNodes(_COMMENTS, comments);
  insertNodes(_DANGLING_ATTRIBUTES, danglingAttributes);
}
var CommentChildNodes = /* @__PURE__ */ new WeakMap();
function getCommentChildNodes(n) {
  const children = Map_get(CommentChildNodes, n, getTransformedNodeChildren);
  if (is_NodeWithBodyOrCases(n) || is_BlockLikeMacroInvocation(n)) {
    for (let i = 0; i < children.length; i++) {
      const attr = children[i];
      if (is_AttributeOrDocComment(attr)) {
        const target = children.find((n2) => start(n2) <= start(attr) && ownStart(n2) >= end(attr));
        if (target) {
          children.splice(i--, 1);
          insertNode(Map_get(CommentChildNodes, target, getTransformedNodeChildren), attr);
        }
      }
    }
  }
  return children;
  function getTransformedNodeChildren(node) {
    if (is_Program(node))
      node.comments ?? (node.comments = []);
    const children2 = getNodeChildren(node);
    if (is_NodeWithBodyNoBody(node)) {
      insertNodes(children2, node.body);
    }
    return children2;
  }
}

// src/format/styling.ts
function needsOuterSoftbreakParens(node) {
  const parent = getParentNode();
  if (!parent)
    return false;
  if (is_ExpressionAsTypeCast(node)) {
    return precedenceNeedsParens(node, parent);
  }
  if (is_FlowControlMaybeValueExpression(parent) && parent.expression === node && flowControlExpressionNeedsOuterParens(parent)) {
    return true;
  }
  if (is_ExpressionWithBodyOrCases_or_BlockLikeMacroInvocation(node) && (is_MemberExpression(parent) && parent.expression === node || is_ExpressionWithBodyOrCases_or_BlockLikeMacroInvocation(parent) && !is_ElseBlock(node, parent))) {
    return true;
  }
  if (is_UnionPattern(node) && is_NodeWithMaybePatternNoUnionBody(parent)) {
    return true;
  }
  if (hasComment(node)) {
    if (is_UnaryExpression(parent)) {
      return true;
    }
    if (hasComment(node, 32 /* Line */)) {
      if (is_ReturnExpression(parent) || is_YieldExpression(parent) && parent.expression === node) {
        return true;
      }
    }
    if (hasComment(node, 2 /* Leading */, (comment) => is_Attribute(comment) && !comment.inner) && !can_have_OuterAttributes(node, parent, true)) {
      return true;
    }
  }
  return false;
}
function needsInnerParens(node) {
  if (needsOuterSoftbreakParens(node)) {
    return false;
  }
  const parent = getParentNode();
  if (!parent) {
    return false;
  }
  if (is_Identifier(node)) {
    return false;
  }
  if (is_Literal(node)) {
    return is_LiteralNumberLike(node) && is_MemberExpression(parent) && node === parent.expression;
  }
  if (is_CallExpression(parent) && parent.callee === node && is_MemberExpression(node)) {
    return !getOptions().actuallyMethodNodes.has(node);
  }
  if (is_ReassignmentNode(node)) {
    if (is_printing_macro()) {
      return false;
    }
    if (is_ClosureFunctionExpression(parent) && node === parent.expression) {
      return true;
    }
    if (is_ExpressionStatement(parent)) {
      return is_StructLiteral(node.left);
    }
    if (is_ReassignmentNode(parent)) {
      return false;
    }
    return true;
  }
  if (is_ParenthesizedNode(parent)) {
    return false;
  }
  if (is_ExpressionStatement(parent)) {
    return false;
  }
  if (is_RangeLiteral(node)) {
    return is_ExpressionAsTypeCast(parent) || is_LogicalExpression(parent) || is_UnaryExpression(parent) || is_PostfixExpression(parent) || is_MemberExpression(parent) && node === parent.expression || is_CallExpression(parent) && node === parent.callee || is_OperationExpression(parent) || is_ComparisonExpression(parent);
  }
  if (is_LetScrutinee(parent) && is_LogicalExpression(node) && parent.expression === node) {
    return true;
  }
  if (is_UnaryExpression(node)) {
    switch (parent.nodeType) {
      case NodeType.MemberExpression:
      case NodeType.AwaitExpression:
        return node === parent.expression;
      case NodeType.CallExpression:
        return node === parent.callee;
      default:
        return false;
    }
  }
  if (is_ExpressionWithBodyOrCases_or_BlockLikeMacroInvocation(node)) {
    if (is_ExpressionWithBodyOrCases(parent)) {
      return !is_ElseBlock(node, parent);
    }
    if (is_LetScrutinee(parent) && parent.expression === node && is_ExpressionWithBodyOrCases(getGrandParentNode())) {
      return true;
    }
    return is_ExpressionAsTypeCast(parent) || is_LogicalExpression(parent) || is_UnaryExpression(parent) || is_PostfixExpression(parent) || is_MemberExpression(parent) && node === parent.expression || is_CallExpression(parent) && node === parent.callee || is_OperationExpression(parent) || is_ComparisonExpression(parent) || is_RangeLiteral(parent);
  }
  if (is_StructLiteral(node)) {
    if (is_ExpressionWithBodyOrCases(parent)) {
      return true;
    }
    if (is_LetScrutinee(parent) && parent.expression === node && is_ExpressionWithBodyOrCases(getGrandParentNode())) {
      return true;
    }
    if (is_UnaryExpression(parent) || is_PostfixExpression(parent) || is_MemberExpression(parent)) {
      return parent.expression === node;
    }
    if (is_CallExpression(parent)) {
      return parent.callee === node;
    }
  }
  if (is_LogicalExpression(node) || is_OperationExpression(node) || is_ComparisonExpression(node) || is_ClosureFunctionExpression(node)) {
    return precedenceNeedsParens(node, parent);
  }
  if (is_TypeFunctionNode(node)) {
    const gp = getGrandParentNode();
    if (node.returnType && is_TypeTraitBound(parent) && is_TypeBoundsStandaloneNode(gp) && last_of(gp.typeBounds) !== parent) {
      return true;
    }
  }
  if (is_TypeBoundsStandaloneNode(node)) {
    return is_UnaryType(parent) && node.typeBounds.length > 1 || is_TypeBoundsStandaloneNode(parent) || is_TypeTraitBound(parent) || is_TypeFunctionNode(parent) && parent.returnType === node;
  }
  if (is_PatternVariableDeclaration(parent)) {
    return is_UnionPattern(node);
  }
  return false;
}
function precedenceNeedsParens(node, parent) {
  if (is_UnaryExpression(parent) || is_PostfixExpression(parent))
    return true;
  if (is_ReassignmentNode(parent))
    return parent.left === node;
  if (is_MemberExpression(parent))
    return parent.expression === node;
  if (is_CallExpression(parent))
    return parent.callee === node;
  if (is_ExpressionAsTypeCast(parent))
    return !is_ExpressionAsTypeCast(node);
  if (is_LogicalExpression(parent))
    return is_LogicalExpression(node) ? parent.nodeType !== node.nodeType : evalPrecedence(node, parent);
  if (is_OperationExpression(parent) || is_ComparisonExpression(parent))
    return evalPrecedence(node, parent);
  return false;
  function evalPrecedence(child, parent2) {
    if (is_ExpressionAsTypeCast(child) || is_ClosureFunctionExpression(child)) {
      return true;
    }
    function getPrec(node2, bool) {
      return getPrecedence(node2, bool);
    }
    const childPRCD = getPrec(child, is_insideScrutinee(child));
    const parentPRCD = getPrec(parent2, is_insideScrutinee(parent2));
    if (parentPRCD > childPRCD) {
      return true;
    }
    if (parentPRCD === childPRCD && parent2.right === child) {
      return true;
    }
    if (parentPRCD === childPRCD && !shouldFlatten(parent2, child)) {
      return true;
    }
    if (parentPRCD < childPRCD && child.tk === TK["%"]) {
      return parentPRCD === PRCD["+-"];
    }
    if (is_BitwiseOperator(parent2.tk) || is_BitwiseOperator(child.tk) && is_EqualityOperator(parent2.tk)) {
      return true;
    }
    return false;
  }
}
function shouldFlatten(parent, node) {
  if (getPrecedence(node, is_insideScrutinee(node)) !== getPrecedence(parent, is_insideScrutinee(parent)))
    return false;
  if (is_ComparisonExpression(parent) && is_ComparisonExpression(node))
    return false;
  if (is_OperationExpression(parent) && is_OperationExpression(node)) {
    if (node.tk === TK["%"] && is_multiplicativeOperator(parent.tk) || parent.tk === TK["%"] && is_multiplicativeOperator(node.tk) || node.tk !== parent.tk && is_multiplicativeOperator(node.tk) && is_multiplicativeOperator(parent.tk) || is_bitshiftOperator(node.tk) && is_bitshiftOperator(parent.tk))
      return false;
  }
  return true;
}
function needsParens(node) {
  return needsOuterSoftbreakParens(node) || needsInnerParens(node);
}
function stmtNeedsSemi(stmt, disregardExprType = false) {
  return pathCallParentOf(stmt, (parent) => needsSemi(parent, stmt, disregardExprType));
}
var NoNode = { nodeType: 0 };
function needsSemi(parent, stmt, disregardExprType = false) {
  const expr = disregardExprType ? NoNode : stmt.expression;
  const hadSemi = !disregardExprType && stmt.semi;
  return !!expr && (forcePreserveSemi() ? true : shouldNeverSemi() ? false : shouldPreserveSemi() ? hadSemi || shouldAlwaysSemi() || canAutoCompleteSemi() : true);
  function forcePreserveSemi() {
    return hadSemi && stmt === last_of(parent.body) && (is_IfBlockExpression(expr) && hasLetScrutineeCondition(expr) && !(is_LetScrutinee(expr.condition) && is_Identifier(expr.condition.expression)) || is_MatchExpression(expr) && !is_Identifier(expr.expression));
  }
  function shouldNeverSemi() {
    return is_ExpressionWithBodyOrCases_or_BlockLikeMacroInvocation(expr);
  }
  function shouldPreserveSemi() {
    return stmt === last_of(parent.body) && (is_ImplicitReturnAbleNode(parent) || is_BlockLikeMacroInvocation(parent));
  }
  function shouldAlwaysSemi() {
    return is_FlowControlExpression(expr) || is_ReassignmentNode(expr);
  }
  function canAutoCompleteSemi() {
    return withPathAt(parent, function checkParent(child) {
      return pathCallParentOf(child, (parent2) => {
        if (is_IfBlockExpression(parent2) && parent2.else === child) {
          return checkParent(parent2);
        }
        if (is_ExpressionStatement(parent2)) {
          if (hasOuterAttributes(parent2))
            return false;
          return stmtNeedsSemi(parent2, true);
        }
        if (is_MatchExpressionCase(parent2) && parent2.expression === child) {
          return pathCallParentOf(parent2, checkParent);
        }
        return false;
      });
    });
  }
}
function canInlineBlockBody(node) {
  if (!is_ExpressionWithBody(node)) {
    return false;
  }
  const body = node.body;
  if (body.length === 0) {
    return canInlineInlineable(node);
  }
  if (body.length === 1) {
    const stmt = body[0];
    if (is_AttributeOrDocComment(stmt)) {
      return true;
    }
    if (is_ExpressionStatement(stmt) && !needsSemi(node, stmt)) {
      const expr = stmt.expression;
      if (is_FlowControlExpression(expr) || is_ClosureFunctionExpression(expr) || is_ExpressionWithBodyOrCases_or_BlockLikeMacroInvocation(expr)) {
        return false;
      }
      return canInlineInlineable(node);
    }
  }
  return false;
}
function canInlineInlineable(node) {
  if (is_ForInBlockExpression(node) || is_LoopBlockExpression(node)) {
    return false;
  }
  if (is_WhileBlockExpression(node)) {
    return true;
  }
  const parent = getParentNode();
  if (is_ExpressionStatement(parent) && (!is_ImplicitReturnAbleNode(node) || pathCallAtParent(parent, (parent2) => stmtNeedsSemi(parent2, true)))) {
    return false;
  }
  if (is_ElseBlock(node, parent)) {
    return pathCallAtParent(parent, canInlineBlockBody);
  }
  if (is_IfBlockExpression(node)) {
    if (!node.else || is_ExpressionWithBodyOrCases_or_BlockLikeMacroInvocation(node.condition) || willBreak(getPrintFn()("condition"))) {
      return false;
    }
    const grandparent = getGrandParentNode();
    if (is_ExpressionStatement(parent) && hasBody(grandparent) && grandparent.body.length > 1) {
      return false;
    }
  }
  return true;
}
function emptyContent(node) {
  switch (node.nodeType) {
    case NodeType.Program:
    case NodeType.MacroRulesDeclaration:
    case NodeType.MacroDeclaration:
    case NodeType.ExternBlockDeclaration:
    case NodeType.ModuleDeclaration:
    case NodeType.TraitDeclaration:
    case NodeType.StructDeclaration:
    case NodeType.MacroInvocation:
    case NodeType.FunctionDeclaration:
    case NodeType.ImplDeclaration:
    case NodeType.UnionDeclaration:
    case NodeType.EnumDeclaration:
    case NodeType.EnumMemberStructDeclaration:
    case NodeType.StructLiteral:
    case NodeType.StructPattern:
      return "";
    case NodeType.BlockExpression:
    case NodeType.WhileBlockExpression:
    case NodeType.ForInBlockExpression:
    case NodeType.TryBlockExpression:
    case NodeType.IfBlockExpression:
      return canInlineInlineable(node) ? is_IfBlockExpression(node) || is_ElseBlock(node, getParentNode()) ? softline : "" : hardline;
    case NodeType.LoopBlockExpression:
    case NodeType.MatchExpression:
      return hardline;
    default:
      if (is_NodeWithBodyNoBody(node)) {
        return "";
      }
      return "";
  }
}
function is_insideScrutinee(target) {
  return withPathAt(target, (n) => stackIncludes("condition") && r(n));
  function r(CHILD) {
    switch (CHILD.nodeType) {
      case NodeType.OrExpression:
      case NodeType.AndExpression:
        return pathCallParentOf(
          CHILD,
          (PARENT) => hasCondition(PARENT) && PARENT.condition === CHILD ? hasLetScrutineeCondition(PARENT) : r(PARENT)
        );
      case NodeType.LetScrutinee:
        return true;
      default:
        return false;
    }
  }
}
function withPathAt(target, callback) {
  if (target === getNode())
    return callback(target);
  if (target === getParentNode())
    return pathCallAtParent(target, () => callback(target));
  if (stackIncludes(target))
    return pathCallAtParent(getParentNode(), () => withPathAt(target, callback));
  return getContext().path.call(() => {
    return callback(target);
  }, ...getAstPath(getNode(), target));
}
function shouldPrintOuterAttributesAbove(node) {
  return is_StatementNode(node) || is_MatchExpressionCase(node) || hasAttributes(node) && node.attributes.some(
    canInlineOuterAttribute(node) ? (attr) => is_DocCommentAttribute(attr) || hasBreaklineAfter(attr) : is_DocCommentAttribute
  );
  function canInlineOuterAttribute(node2) {
    return is_EnumMemberDeclaration(node2) || is_StructPropertyDeclaration(node2) || is_StructLiteralProperty(node2) || is_StructPatternProperty(node2);
  }
}

// src/format/core.ts
function isNoopExpressionStatement(node) {
  return is_ExpressionStatement(node) && void 0 === node.expression && !hasAttributes(node) && !hasComment(node);
}
function is_xVariableEqualishLike(node) {
  switch (node.nodeType) {
    case NodeType.LetScrutinee:
    case NodeType.LetVariableDeclaration:
    case NodeType.ConstVariableDeclaration:
    case NodeType.StaticVariableDeclaration:
    case NodeType.TypeAliasDeclaration:
    case NodeType.TraitAliasDeclaration:
      return true;
    default:
      return false;
  }
}
function is_BinaryishExpression(node) {
  switch (node.nodeType) {
    case NodeType.OrExpression:
    case NodeType.AndExpression:
    case NodeType.OperationExpression:
    case NodeType.ComparisonExpression:
      return true;
    default:
      return false;
  }
}
function is_StructSpread(node) {
  switch (node.nodeType) {
    case NodeType.StructLiteralPropertySpread:
    case NodeType.StructLiteralRestUnassigned:
    case NodeType.RestPattern:
      return true;
    default:
      return false;
  }
}
function isConciselyPrintedArray(node) {
  return node.items.length > 1 && node.items.every(
    (element) => (is_LiteralNumberLike(element) || is_MinusExpression(element) && is_LiteralNumberLike(element.expression) && !hasComment(element.expression)) && !hasComment(element, 4 /* Trailing */ | 32 /* Line */, (comment) => !hasBreaklineBefore(comment))
  );
}
function printNumber(rawNumber) {
  return rawNumber.toLowerCase().replace(/^([\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^(\d+)e[+-]?0+$/, "$1.0").replace(/^([\d.]+)e[+-]?0+$/, "$1").replace(/\.(\d+?)0+(?=e|$)/, ".$1").replace(/\.(?=e|$)/, ".0");
}
function printOnOwnLine(node, printed) {
  return [printed, maybeEmptyLine(node)];
}
function maybeEmptyLine(node) {
  return isNextLineEmpty(node) ? [hardline, hardline] : hardline;
}
function printBodyOrCases(print4, node) {
  const p = [];
  if (is_MatchExpression(node)) {
    pathCallEach(node, "cases", (mCase) => {
      p.push({
        node: mCase,
        doc: is_MatchExpressionCase(mCase) && !is_ExpressionWithBodyOrCases(mCase.expression) ? [print4(), ","] : print4()
      });
    });
  } else {
    pathCallEach(node, "body", (stmt) => {
      if (!isNoopExpressionStatement(stmt)) {
        p.push({ node: stmt, doc: print4() });
      }
    });
  }
  const printed = bumpInnerAttributes(p).map(
    ({ doc: doc2, node: node2 }, i, a) => iLast(i, a) ? group(doc2) : printOnOwnLine(node2, group(doc2))
  );
  const comments = printDanglingCommentsForInline(node, "body" /* body */);
  if (comments)
    printed.push(comments);
  const ccomments = printDanglingCommentsForInline(node, "cases" /* cases */);
  if (ccomments)
    printed.push(ccomments);
  if (is_Program(node) && is_SourceFile(getParentNode()) && printed.length > 0 && !comments) {
    printed.push(hardline);
  }
  return printed;
  function bumpInnerAttributes(arr) {
    return arr.sort((a, b) => ownStart(a.node) - ownStart(b.node));
  }
}
function printMacroRules(print4, node) {
  return !Array.isArray(node.rules) ? print4("rules") : node.rules.length > 0 ? [" {", indent([hardline, ...print4.join("rules", (rule) => maybeEmptyLine(rule))]), hardline, "}"] : [" {", printDanglingCommentsForInline(node, "rules" /* rules */) || emptyContent(node), "}"];
}
function is_unary_token(item) {
  switch (item && is_PunctuationToken(item) ? item.tk : TK.None) {
    case TK["-"]:
    case TK["*"]:
    case TK["&"]:
    case TK["#"]:
    case TK["!"]:
    case TK["~"]:
      return true;
    case TK["?"]:
      return !/\s/.test(getOptions().originalText.charAt(end(item)));
    default:
      return false;
  }
}
function can_unary(node) {
  return (!is_PunctuationToken(node) || is_unary_token(node)) && (!is_MacroGroup(node) || is_optional_unary(node));
}
function is_optional_token(item) {
  return !!item && is_MacroGroup(item) && item.kind === "?" && item.segments.length === 1 && is_PunctuationToken(item.segments[0]);
}
function is_optional_unary(item) {
  return is_optional_token(item) && is_unary_token(item.segments[0]);
}
function printRuleMatch(print4, rule) {
  return print_map(rule, "match");
  function print_map(node, property) {
    const arr = node[property];
    const shouldHug = should_hug(arr);
    const dline = arr.dk === DelimKind["{}"] ? line : shouldHug ? "" : softline;
    const isParamsLike = is_params_like(arr);
    const shouldBreak = should_break(arr);
    const d = getDelimChars(arr);
    if (arr.length === 0)
      return [d.left, printDanglingCommentsForInline(node, DCM[property]), d.right];
    const printed = flat(print4.map_join(property, print_item, join_item));
    return group([d.left, !dline ? printed : [indent([dline, printed]), dline], d.right], {
      shouldBreak,
      id: getMacroGroupId(node)
    });
    function should_hug(arr2) {
      if (node === rule)
        return false;
      let has_nonToken = false;
      return arr2.every((item) => !is_MacroGroup(item) && (is_PunctuationToken(item) || has_nonToken !== (has_nonToken = true)));
    }
    function should_break(arr2) {
      let has_decl = false;
      return arr2.some(
        (item, i, a) => is_match_any(item) && arr2.length !== 1 || !iLast(i, a) && isDeclStart(item, a[i + 1]) && has_decl === (has_decl = true)
      );
    }
    function print_item(item, index, arr2) {
      switch (item.nodeType) {
        case NodeType.Identifier:
        case NodeType.LtIdentifier:
        case NodeType.Literal:
        case NodeType.PunctuationToken:
        case NodeType.MacroParameterDeclaration:
          return print4();
        case NodeType.MacroGroup:
          return printComments(["$", print_map(item, "segments"), print4("sep"), item.kind]);
        case NodeType.DelimGroup:
          return printComments(print_map(item, "segments"));
      }
      function printComments(doc2) {
        const printed2 = withComments(item, doc2);
        const comment = getFirstComment(item, 2 /* Leading */ | 32 /* Line */);
        return comment && index !== 0 ? isPreviousLineEmpty(comment) && typeof join_item(arr2[index - 1], item, index === 1 ? void 0 : arr2[index - 2]) === "string" ? [hardline, hardline, printed2] : [hardline, printed2] : printed2;
      }
    }
    function is_params_like(arr2) {
      return arr2.some(function isComma(item) {
        switch (item.nodeType) {
          case NodeType.PunctuationToken:
            return TK[","] === item.tk;
          case NodeType.MacroGroup:
            return !!item.sep && isComma(item.sep) || is_params_like(item.segments);
        }
      });
    }
    function join_item(item, next, prev) {
      if (is_PunctuationToken(item)) {
        switch (item.tk) {
          case TK[","]:
          case TK[";"]:
            return line;
          case TK["::"]:
          case TK[".."]:
          case TK["..."]:
          case TK["."]:
          case TK["#"]:
            return "";
          case TK["!"]:
            if (prev && is_ident(prev) && is_DelimGroup(next)) {
              return next.segments.dk === DelimKind["{}"] ? " " : "";
            }
            break;
          case TK["@"]:
            return is_ident(next) && (!prev || is_MacroGroup(prev) || is_DelimGroup(prev)) ? "" : " ";
        }
        return is_unary_token(item) && (!prev || !is_ident(prev)) && can_unary(next) ? "" : " ";
      }
      switch (is_PunctuationToken(next) ? next.tk : TK.None) {
        case TK[","]:
        case TK[";"]:
        case TK[":"]:
        case TK["::"]:
        case TK[".."]:
        case TK["..."]:
        case TK["."]:
          return "";
        case TK["!"]:
          if (is_ident(item)) {
            return "";
          }
      }
      if (is_match_any(item)) {
        return line;
      }
      {
        const sep_tk = is_MacroGroup(item) && item.sep && is_PunctuationToken(item.sep) ? item.sep.tk : TK.None;
        switch (sep_tk) {
          case TK["::"]:
          case TK["."]:
            return "";
          case TK[","]:
          case TK[";"]:
            return sep_tk === maybe_tk(next) ? ifBreak(line, " ", { groupId: getMacroGroupId(item) }) : line;
        }
      }
      if (is_optional_token(item)) {
        switch (item.segments[0].tk) {
          case TK["+"]:
          case TK["|"]:
            return " ";
          case TK["::"]:
            return "";
        }
        if (is_unary_token(item.segments[0])) {
          return "";
        }
      }
      if (is_DelimGroup(item) || is_MacroGroup(item)) {
        if (item.segments.dk === DelimKind["{}"]) {
          return line;
        }
        if (is_MacroGroup(item) && item.segments.length === 2) {
          const { 0: left, 1: right } = item.segments;
          if (is_PunctuationToken(left) && is_DelimGroup(right) && left.tk === TK["#"] && right.segments.dk === DelimKind["[]"]) {
            return hardline;
          }
        }
        return isParamsLike || is_tk(next) ? " " : line;
      }
      const next_1 = next !== last_of(arr) && arr[arr.indexOf(next) + 1];
      if (is_ident(item) && is_DelimGroup(next) && next.segments.dk === DelimKind["()"]) {
        if (!next_1 || !is_match_any(next_1)) {
          return "";
        }
      }
      if (is_match_any(next) && (!is_DelimGroup(next) || next_1 && is_match_any(next_1))) {
        return line;
      }
      return " ";
    }
  }
  function is_ident(item) {
    switch (item.nodeType) {
      case NodeType.Identifier:
        return true;
      case NodeType.MacroParameterDeclaration:
        return item.ty.name === "ident";
      default:
        return false;
    }
  }
  function is_tk(item) {
    return is_PunctuationToken(item) || is_optional_token(item);
  }
  function maybe_tk(item) {
    switch (item.nodeType) {
      case NodeType.PunctuationToken:
        return item.tk;
      case NodeType.MacroGroup:
        return is_optional_token(item) ? item.segments[0].tk : TK.None;
      default:
        return TK.None;
    }
  }
  function isDeclStart(item, next) {
    if (is_Identifier(item)) {
      switch (item.name) {
        case "fn":
        case "mod":
        case "use":
        case "struct":
        case "trait":
        case "union":
        case "enum":
        case "impl":
        case "type":
        case "let":
        case "static":
        case "const":
          if (is_ident(next)) {
            return true;
          }
      }
    }
    return false;
  }
  function is_match_any(item) {
    return !!item && (is_MacroGroup(item) && !item.sep && (item.kind === "*" || item.kind === "+") && item.segments.length === 1 && is_MacroParameterDeclaration(item.segments[0]) && item.segments[0].ty.name === "tt" || is_DelimGroup(item) && item.segments.length === 1 && is_match_any(item.segments[0]));
  }
}
function printRuleTransform(print4, node, t = getDelimChars(node.transform)) {
  var _a;
  const text = node.transform.loc.sliceText();
  const fline = is_MacroInlineRuleDeclaration(node) ? hardline : line;
  if (/^. *\n/.test(text)) {
    return [
      dedentToRoot([
        t.left,
        fline,
        text.slice(1, -1).replace(/^ *\n|\n\s*$/g, "")
      ]),
      fline,
      t.right
    ];
  } else if (/\n/.test(text) && node.transform.length === 1) {
    const segment = node.transform[0];
    if (is_DelimGroup(segment) || is_MacroGroup(segment)) {
      const inner = is_DelimGroup(segment) ? getDelimChars(segment.segments) : { left: "$(", right: `)${((_a = segment.sep) == null ? void 0 : _a.loc.getOwnText()) ?? ""}${segment.kind}` };
      return [
        dedentToRoot([
          t.left,
          [
            indent(indent([fline, inner.left])),
            line,
            segment.segments.loc.sliceText(1, -1).replace(/^ *\n|\n\s*$/g, ""),
            indent(indent([line, inner.right]))
          ]
        ]),
        fline,
        t.right
      ];
    }
  }
  return text;
}
function is_AssignmentOrVariableDeclarator(node) {
  return is_ReassignmentNode(node) || is_VariableDeclarationNode(node);
}
function hasLeadingOwnLineComment(node) {
  if (is_NodeWithBodyOrCases(node) && hasComment(node, 2 /* Leading */, is_Attribute)) {
    return true;
  }
  return hasComment(
    node,
    2 /* Leading */,
    (comment) => hasNewline(end(comment)) && !getContext().options.danglingAttributes.includes(comment)
  );
}
function isComplexDestructuring(node) {
  if (is_ReassignmentExpression(node)) {
    const leftNode = node.left;
    return is_StructLiteral(leftNode) && leftNode.properties.length > 2 && leftNode.properties.some((property) => is_StructLiteralProperty(property) || is_StructLiteralPropertySpread(property));
  }
  if (is_VariableDeclarationNode(node) || is_MatchExpressionCase(node) || is_LetScrutinee(node)) {
    const leftNode = node.pattern;
    return is_StructPattern(leftNode) && leftNode.properties.length > 2 && leftNode.properties.some((property) => is_StructPatternPropertyDestructured(property));
  }
  return false;
}
function isArrowFunctionVariableDeclarator(node) {
  return is_VariableDeclarationNode(node) && node.expression && is_ClosureFunctionExpression(node.expression);
}
function isObjectPropertyWithShortKey(node, keyDoc) {
  if (!is_StructProperty(node))
    return false;
  keyDoc = cleanDoc(keyDoc);
  const MIN_OVERLAP_FOR_BREAK = 3;
  return typeof keyDoc === "string" && keyDoc.length < getContext().options.tabWidth + MIN_OVERLAP_FOR_BREAK;
}
function print_CallExpression_end(print4, node) {
  return [f`::${printTypeArguments(print4, node)}`, printCallArguments(print4, node)];
}
function printCallExpression(print4, node) {
  if (shouldPrint_CallExpression_chain(node) && !pathCall(node, "callee", (node2) => needsParens(node2))) {
    return printMemberChain(print4, node);
  }
  const contents = [print4("callee"), ...print_CallExpression_end(print4, node)];
  if (is_CallExpression_or_CallLikeMacroInvocation(node.callee)) {
    return group(contents);
  }
  return contents;
}
function printTypeAnnotation(print4, node) {
  return node.typeAnnotation && !is_MissingNode(node.typeAnnotation) ? [": ", print4("typeAnnotation")] : "";
}
function printAnnotatedPattern(print4, node) {
  return [print4("pattern"), printTypeAnnotation(print4, node)];
}
function isLoneShortArgument(node) {
  if (hasComment(node)) {
    return false;
  }
  if (is_Identifier(node) && is_short(node.name) || is_LiteralNumberLike(node) && !hasComment(node)) {
    return true;
  }
  if (is_LiteralStringLike(node)) {
    return is_short(node.value) && !node.value.includes("\n");
  }
  return is_LiteralBooleanLike(node);
}
var toLayout = ["break-after-operator", "never-break-after-operator", "fluid", "break-lhs", "chain", "chain-tail", "chain-tail-arrow-chain", "only-left"];
function printMemberExpression(print4, node) {
  const objectDoc = print4("expression");
  const lookupDoc = printMemberLookup(print4, node);
  const shouldInline = shouldInlineMemberExpression(node, objectDoc);
  return label(objectDoc.label === "member-chain" ? "member-chain" : "member", [
    objectDoc,
    shouldInline ? lookupDoc : group(indent([softline, lookupDoc]))
  ]);
}
function shouldInlineMemberExpression(node, objectDoc) {
  const { path } = getContext();
  const parent = getParentNode();
  let i = 0;
  let nmparent = parent;
  while (nmparent && (is_MemberExpression(nmparent) || is_PostfixExpression(nmparent))) {
    nmparent = path.getParentNode(i++);
  }
  const shouldInline = nmparent && (is_ExpressionPath(nmparent) || is_ReassignmentNode(nmparent) && !is_Identifier(nmparent.left)) || !node.computed || is_Identifier(node.expression) && is_Identifier(node.property) && !is_MemberExpression(parent) || is_AssignmentOrVariableDeclarator(parent) && (is_CallExpression_or_CallLikeMacroInvocation(node.expression) && node.expression.arguments.length > 0 || is_PostfixExpression(node.expression) && is_CallExpression_or_CallLikeMacroInvocation(node.expression.expression) && node.expression.expression.arguments.length > 0 || objectDoc.label === "member-chain");
  return shouldInline;
}
function printAssignment(leftDoc, operator, rightPropertyName) {
  const assignmentNode = getNode();
  const rightNode = assignmentNode[rightPropertyName];
  if (!rightNode)
    return group(leftDoc);
  const layout = chooseLayout();
  const rightDoc = getPrintFn()(rightPropertyName, { assignmentLayout: layout });
  const res = function() {
    switch (layout) {
      case 0 /* break-after-operator */:
        return group([group(leftDoc), operator, group(indent([line, rightDoc]))]);
      case 1 /* never-break-after-operator */:
        return group([group(leftDoc), operator, " ", rightDoc]);
      case 2 /* fluid */: {
        const groupId = Symbol("assignment");
        return group([
          group(leftDoc),
          operator,
          group(indent(line), { id: groupId }),
          lineSuffixBoundary,
          indentIfBreak(rightDoc, { groupId })
        ]);
      }
      case 3 /* break-lhs */:
        return group([leftDoc, operator, " ", group(rightDoc)]);
      case 4 /* chain */:
        return [group(leftDoc), operator, line, rightDoc];
      case 5 /* chain-tail */:
        return [group(leftDoc), operator, indent([line, rightDoc])];
      case 6 /* chain-tail-arrow-chain */:
        return [group(leftDoc), operator, rightDoc];
      default:
        exit.never();
    }
  }();
  return label(toLayout[layout], res);
  function chooseLayout() {
    if (is_ReassignmentExpression(assignmentNode) && is_printing_macro() || is_GenericParameterDeclaration(assignmentNode) || is_TypeCallNamedArgument(assignmentNode)) {
      return 1 /* never-break-after-operator */;
    }
    const isTail = !is_ReassignmentNode(rightNode);
    const shouldUseChainFormatting = getContext().path.match(
      is_ReassignmentNode,
      is_AssignmentOrVariableDeclarator,
      (node) => !isTail || !is_ExpressionStatement(node) && !is_VariableDeclarationNode(node)
    );
    if (shouldUseChainFormatting) {
      return !isTail ? 4 /* chain */ : is_ClosureFunctionExpression(rightNode) && is_ClosureFunctionExpression(rightNode.expression) ? 6 /* chain-tail-arrow-chain */ : 5 /* chain-tail */;
    }
    const isHeadOfLongChain = !isTail && is_ReassignmentNode(rightNode.right);
    if (isHeadOfLongChain || hasLeadingOwnLineComment(rightNode)) {
      return 0 /* break-after-operator */;
    }
    if (isComplexDestructuring(assignmentNode) || hasComplexGenerics(assignmentNode) || hasComplexTypeAnnotation(assignmentNode) || isArrowFunctionVariableDeclarator(assignmentNode) && canBreak(leftDoc)) {
      return 3 /* break-lhs */;
    }
    const hasShortKey = isObjectPropertyWithShortKey(assignmentNode, leftDoc);
    if (pathCall(assignmentNode, rightPropertyName, (rightNode2) => shouldBreakAfterOperator(rightNode2, hasShortKey))) {
      return 0 /* break-after-operator */;
    }
    if (hasShortKey || is_Literal(rightNode)) {
      return 1 /* never-break-after-operator */;
    }
    return 2 /* fluid */;
  }
  function shouldBreakAfterOperator(rightNode2, hasShortKey) {
    if (is_MemberExpression(rightNode2) && shouldInlineMemberExpression(rightNode2, getPrintFn()("expression"))) {
      return false;
    }
    if (is_BinaryishExpression(rightNode2) && !shouldInlineLogicalExpression(rightNode2)) {
      return true;
    }
    if (is_IfBlockExpression(rightNode2)) {
      return false;
    }
    if (hasShortKey) {
      return false;
    }
    return function unwrap(node) {
      if (is_UnaryExpression(node) || is_PostfixExpression(node)) {
        return pathCall(node, "expression", unwrap);
      }
      if (is_LiteralStringLike(node)) {
        return true;
      }
      return isPoorlyBreakableMemberOrCallChain(node);
    }(rightNode2);
    function isPoorlyBreakableMemberOrCallChain(topNode) {
      return function unwrap(node) {
        if (is_MemberExpression(node) || is_PostfixExpression(node) || is_UnaryExpression(node)) {
          return pathCall(node, "expression", unwrap);
        }
        if (is_ExpressionPath(node)) {
          return pathCall(node, "namespace", (namespace) => !namespace || unwrap(namespace));
        }
        if (is_CallExpression_or_CallLikeMacroInvocation(node)) {
          const doc2 = printCallExpression(getPrintFn(), node);
          if (doc2.label === "member-chain") {
            return false;
          }
          const args = node.arguments;
          const isPoorlyBreakableCall = args.length === 0 || args.length === 1 && isLoneShortArgument(args[0]);
          if (!isPoorlyBreakableCall) {
            return false;
          }
          if (hasComplexTypeArguments(node)) {
            return false;
          }
          return pathCall(node, "callee", unwrap);
        }
        return topNode === node ? false : is_Identifier(node);
      }(topNode);
    }
  }
}
function is_MemberExpression_with_RangeOrLiteral_Property(node) {
  return !!node && is_MemberExpression(node) && (node.computed ? is_Literal_or_SimpleRangeLiteral(node.property) : is_Literal(node.property));
}
function is_Literal_or_SimpleRangeLiteral(node) {
  return is_Literal(node) ? true : is_RangeLiteral(node) ? (!node.lower || is_Literal(node.lower)) && (!node.upper || is_Literal(node.upper)) : false;
}
function printMemberLookup(print4, node) {
  return !node.computed ? [".", print4("property")] : is_Literal_or_SimpleRangeLiteral(node.property) ? ["[", print4("property"), "]"] : group(["[", indent([softline, print4("property")]), softline, "]"]);
}
function shouldPrint_CallExpression_chain(node) {
  return is_MemberAccessLike(node.callee) || is_CallExpression_or_CallLikeMacroInvocation(node.callee);
}
function is_MemberAccessLike(node) {
  switch (node.nodeType) {
    case NodeType.ExpressionPath:
    case NodeType.MemberExpression:
      return true;
    default:
      return false;
  }
}
function printMemberChain(print4, node) {
  const parent = getParentNode();
  const isExpressionStatement = !parent || is_ExpressionStatement(parent);
  const { printedNodes, groups } = splitCallChains(node);
  const shouldMerge = groups.length >= 2 && !hasComment(groups[1][0].node) && shouldNotWrap(groups);
  const printedGroups = groups.map(printGroup);
  const oneLine = printedGroups;
  const cutoff = shouldMerge ? 3 : 2;
  const nodeHasComment = printedNodes.slice(1, -1).some(({ node: node2 }) => hasComment(node2, 2 /* Leading */)) || printedNodes.slice(0, -1).some(({ node: node2 }) => hasComment(node2, 4 /* Trailing */)) || groups[cutoff] && hasComment(groups[cutoff][0].node, 2 /* Leading */);
  if (groups.length <= cutoff && !nodeHasComment) {
    return isLongCurriedCallExpression(node) ? oneLine : group(oneLine);
  }
  const lastNodeBeforeIndent = last_of(groups[shouldMerge ? 1 : 0]).node;
  const shouldHaveEmptyLineBeforeIndent = !is_CallExpression_or_CallLikeMacroInvocation(lastNodeBeforeIndent) && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);
  const expanded = [
    printGroup(groups[0]),
    shouldMerge ? groups.slice(1, 2).map(printGroup) : "",
    shouldHaveEmptyLineBeforeIndent ? hardline : "",
    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))
  ];
  const callExpressions = printedNodes.map(({ node: node2 }) => node2).filter(is_CallExpression_or_CallLikeMacroInvocation);
  const result = nodeHasComment || callExpressions.length > 2 && callExpressions.some((expr) => expr.arguments.some((arg) => !isSimpleCallArgument(arg, 0))) || printedGroups.slice(0, -1).some(willBreak) || lastGroupWillBreakAndOtherCallsHaveFunctionArguments() ? group(expanded) : [shouldHaveEmptyLineBeforeIndent || willBreak(oneLine) ? breakParent : "", conditionalGroup([oneLine, expanded])];
  return label("member-chain", result);
  function shouldInsertEmptyLineAfter(node2) {
    let start7 = end(node2);
    const last = getNextNonSpaceNonCommentCharacterIndex(node2);
    const { originalText } = getContext().options;
    while (start7 < last) {
      if (originalText.charAt(start7) === ")") {
        return isNextLineEmptyAfterIndex(start7 + 1);
      }
      start7++;
    }
    return isNextLineEmpty(node2);
  }
  function isFactory(name) {
    return /^[A-Z]|^[$_]+$/.test(name);
  }
  function isShort(name) {
    return name.length <= getContext().options.tabWidth;
  }
  function shouldNotWrap(groups2) {
    const hasComputed = groups2[1].length > 0 && is_MemberExpression(groups2[1][0].node) && groups2[1][0].node.computed;
    if (groups2[0].length === 1) {
      const firstNode = groups2[0][0].node;
      return is_Identifier(firstNode) && (isFactory(firstNode.name) || isExpressionStatement && isShort(firstNode.name) || hasComputed);
    }
    const lastNode = last_of(groups2[0]).node;
    const lastNodeLeft = is_ExpressionPath(lastNode) ? lastNode.namespace : is_MemberExpression(lastNode) ? lastNode.expression : void 0;
    return lastNodeLeft && is_Identifier(lastNodeLeft) && (isFactory(lastNodeLeft.name) || hasComputed);
  }
  function printGroup(g) {
    const printed = [];
    if (printedNodes[0] === g[0]) {
      for (const item of printedNodes) {
        if (item.needsParens)
          printed.unshift("(");
      }
    }
    for (const item of g) {
      printed.push(item.printed);
      if (item.needsParens)
        printed.push(")");
    }
    return printed;
  }
  function printIndentedGroup(groups2) {
    if (groups2.length === 0)
      return "";
    return indent(group([hardline, join(hardline, groups2.map(printGroup))]));
  }
  function lastGroupWillBreakAndOtherCallsHaveFunctionArguments() {
    const lastGroupNode = last_of(last_of(groups)).node;
    const lastGroupDoc = last_of(printedGroups);
    return is_CallExpression_or_CallLikeMacroInvocation(lastGroupNode) && willBreak(lastGroupDoc) && callExpressions.slice(0, -1).some((node2) => node2.arguments.some(is_ClosureFunctionExpression));
  }
  function splitCallChains(topNode) {
    const printedNodes2 = [
      {
        node: topNode,
        needsParens: false,
        printed: print_CallExpression_end(print4, node)
      }
    ];
    pathCall(topNode, "callee", function READ_LEFT(node2) {
      if (is_CallExpression_or_CallLikeMacroInvocation(node2) && shouldPrint_CallExpression_chain(node2)) {
        unshift(print_CallExpression_end(print4, node2), shouldInsertEmptyLineAfter(node2));
        pathCall(node2, "callee", READ_LEFT);
      } else if (is_MemberExpression(node2)) {
        unshift(printMemberLookup(print4, node2));
        pathCall(node2, "expression", READ_LEFT);
      } else if (is_ExpressionPath(node2)) {
        unshift(["::", print4("segment")]);
        if (node2.namespace) {
          pathCall(node2, "namespace", READ_LEFT);
        }
      } else if (is_PostfixExpression(node2)) {
        unshift(is_UnwrapExpression(node2) ? "?" : ".await");
        pathCall(node2, "expression", READ_LEFT);
      } else {
        printedNodes2.unshift({ node: node2, needsParens: false, printed: print4() });
      }
      function unshift(printed, needsHardlineAfter = false) {
        printedNodes2.unshift({
          node: node2,
          needsParens: is_MemberAccessLike(node2) && needsParens(node2),
          printed: [withComments(node2, printed), needsHardlineAfter ? hardline : ""]
        });
      }
    });
    const groups2 = spread(function* () {
      let i = 0;
      let currentItem = printedNodes2[i];
      function testNextItem(fn) {
        return i + 1 < printedNodes2.length && fn(printedNodes2[i + 1]);
      }
      function readGroup(fn) {
        return spread(function* () {
          for (var _item of fn()) {
            yield currentItem;
            if (++i < printedNodes2.length)
              currentItem = printedNodes2[i];
            else
              break;
          }
        });
      }
      function* loop(condition) {
        while (condition(currentItem))
          yield currentItem;
      }
      function* until(condition) {
        while (!condition(currentItem))
          yield currentItem;
      }
      yield readGroup(function* () {
        const isCallExpression = is_CallExpression_or_CallLikeMacroInvocation(currentItem.node);
        yield currentItem;
        yield* loop(
          ({ node: node2, needsParens: needsParens2 }) => is_PostfixExpression(node2) || is_CallExpression_or_CallLikeMacroInvocation(node2) || is_MemberExpression_with_RangeOrLiteral_Property(node2) || needsParens2
        );
        if (!isCallExpression) {
          yield* loop(
            ({ node: node2, needsParens: needsParens2 }) => is_MemberAccessLike(node2) && testNextItem(({ node: node3 }) => is_MemberAccessLike(node3))
          );
        }
      });
      while (i < printedNodes2.length) {
        yield readGroup(function* () {
          let isCallExpression = false;
          yield* until(
            ({ node: node2 }) => (isCallExpression = is_CallExpression_or_CallLikeMacroInvocation(node2)) || hasComment(node2, 4 /* Trailing */)
          );
          yield currentItem;
          if (isCallExpression) {
            yield* loop(({ node: node2 }) => is_MemberExpression_with_RangeOrLiteral_Property(node2));
            yield* until(
              ({ node: node2 }) => is_MemberAccessLike(node2) || hasComment(node2, 4 /* Trailing */)
            );
          }
        });
      }
    });
    return { printedNodes: printedNodes2, groups: groups2 };
  }
}
function isSimpleCallArgument(node, depth) {
  if (depth >= 2)
    return false;
  if (is_IdentifierOrIndex(node)) {
    return true;
  }
  if (is_Literal(node)) {
    return !is_LiteralStringLike(node) || !node.value.includes("\n");
  }
  if (is_ArrayOrTupleLiteral(node)) {
    return node.items.every(isChildSimple);
  }
  if (is_StructLiteral(node)) {
    return isSimpleCallArgument(node.struct, depth) && node.properties.every(
      (prop) => is_StructLiteralPropertySpread(prop) ? isChildSimple(prop.expression) : is_StructLiteralProperty(prop) ? isChildSimple(prop.value) : true
    );
  }
  if (is_CallExpression_or_CallLikeMacroInvocation(node)) {
    return isSimpleCallArgument(node.callee, depth) && (node.typeArguments ?? []).every(isChildSimple) && node.arguments.every(isChildSimple);
  }
  if (is_MemberExpression(node)) {
    return isSimpleCallArgument(node.expression, depth) && isSimpleCallArgument(node.property, depth);
  }
  if (is_ExpressionTypeCast(node)) {
    return isSimpleCallArgument(node.typeCallee, depth) && node.typeArguments.every(isChildSimple);
  }
  if (is_ExpressionPath(node)) {
    const namespace = node.namespace;
    return !namespace || isSimpleCallArgument(namespace, depth);
  }
  if (is_UnaryExpression(node) || is_PostfixExpression(node)) {
    return isSimpleCallArgument(node.expression, depth);
  }
  return false;
  function isChildSimple(child) {
    return isSimpleCallArgument(child, depth + 1);
  }
}
function isLongCurriedCallExpression(node) {
  const parent = getParentNode();
  return is_CallExpression_or_CallLikeMacroInvocation(node) && is_CallExpression_or_CallLikeMacroInvocation(parent) && parent.callee === node && node.arguments.length > parent.arguments.length && parent.arguments.length > 0;
}
function printTypeArguments(print4, node) {
  return !node.typeArguments ? "" : node.typeArguments.length === 0 ? ["<", printDanglingCommentsForInline(node, "typeArguments" /* typeArguments */), ">"] : hasComplexTypeArguments(node) ? group(
    [
      "<",
      indent([softline, print4.join("typeArguments", [",", line])]),
      softline,
      ">"
    ],
    { id: getTypeParametersGroupId(node) }
  ) : ["<", print4.join("typeArguments", ", "), ">"];
}
function printLtParameters(print4, node) {
  return !node.ltParameters ? "" : node.ltParameters.length === 0 ? ["for<", printDanglingCommentsForInline(node, "ltParameters" /* ltParameters */), "> "] : hasComplexLtParameters(node) ? group(
    [
      "for<",
      indent([softline, print4.join("ltParameters", [",", line])]),
      softline,
      "> "
    ],
    { id: getTypeParametersGroupId(node) }
  ) : ["for<", print4.join("ltParameters", ", "), "> "];
}
function printGenerics(print4, node) {
  return group(
    !node.generics ? "" : hasComplexGenerics(node) ? [
      "<",
      indent([softline, print4.join("generics", [",", line])]),
      hasMultipleHeritage(node) ? indent([softline, ">"]) : [softline, ">"]
    ] : [
      "<",
      print4.join("generics", ", "),
      printDanglingCommentsForInline(node, "generics" /* generics */),
      ">"
    ]
  );
}
function getPrintedTypeBounds(print4, node) {
  if (!hasTypeBounds(node) || node.typeBounds.length === 0)
    return "";
  if (node.typeBounds.length === 1)
    return print4.map("typeBounds");
  const printed = print4.join("typeBounds", (_, __, prev) => !prev ? " +" : [" +", line]);
  return [printed.shift(), indent([line, printed])];
}
function printTypeBounds(operator, print4, node) {
  if (!hasTypeBounds(node))
    return "";
  const printed = getPrintedTypeBounds(print4, node);
  return printed ? group([operator, " ", printed]) : operator;
}
function printLtBounds(left, print4, node) {
  return group(
    !node.ltBounds ? "" : node.ltBounds.length === 0 ? [left, " "] : [left, " ", print4.map("ltBounds", (typeBound, i) => i === 0 ? print4() : indent([line, "+ ", print4()]))]
  );
}
function printWhereBounds(print4, node) {
  if (!node.whereBounds || node.whereBounds.length === 0)
    return "";
  return adjustDeclarationClause(
    node,
    "where",
    print4.join("whereBounds", [",", line])
  );
}
function printDeclarationTypeBounds(print4, node, operator) {
  return hasTypeBounds(node) ? adjustDeclarationClause(node, operator, getPrintedTypeBounds(print4, node)) : "";
}
function printImplTraitForType(print4, node) {
  return node.trait ? [print4("trait"), adjustDeclarationClause(node, "for", print4("typeTarget"))] : print4("typeTarget");
}
function adjustDeclarationClause(node, clause, content) {
  const isTypeBoundsClause = clause === ":" || clause === " =";
  return (clause === "where" || hasMultipleHeritage(node) ? indent : Identity)([
    clause === "->" ? hasMultipleHeritage(node) && node.whereBounds.length > 1 ? line : " " : clause === "where" ? line : isTypeBoundsClause ? hasMultipleHeritage(node) ? softline : "" : line,
    clause,
    content && group(
      clause === "where" ? indent([line, content]) : clause === "->" || isTypeBoundsClause ? [" ", content] : [line, content]
    )
  ]);
}
function hasNonWhereHeritageClause(node) {
  switch (node.nodeType) {
    case NodeType.FunctionDeclaration:
      return !!node.returnType;
    case NodeType.StructDeclaration:
    case NodeType.TupleStructDeclaration:
    case NodeType.UnionDeclaration:
    case NodeType.EnumDeclaration:
      return false;
    case NodeType.TypeAliasDeclaration:
    case NodeType.TraitDeclaration:
    case NodeType.TraitAliasDeclaration:
      return hasTypeBounds(node);
    case NodeType.ImplDeclaration:
    case NodeType.NegativeImplDeclaration:
      return !!node.trait;
  }
}
function hasMultipleHeritage(node) {
  return !!node.whereBounds && hasNonWhereHeritageClause(node);
}
var getMacroGroupId = createGroupIdMapper("MacroGroup");
var getHeritageGroupId = createGroupIdMapper("heritageGroup");
var getTypeParametersGroupId = createGroupIdMapper("typeParameters");
function createGroupIdMapper(description) {
  const groupIds = /* @__PURE__ */ new WeakMap();
  return (node) => Map_get(groupIds, node, () => Symbol(description));
}
function printDanglingCommentsForInline(node, marker) {
  const hasOnlyBlockComments = !hasComment(node, 32 /* Line */ | 8 /* Dangling */, (comment) => !marker || comment.marker === marker) || is_Program(node);
  const printed = printDanglingComments(node, hasOnlyBlockComments, marker);
  return printed && (hasOnlyBlockComments && !is_Program(node) ? willBreak(printed) ? [indent([hardline, printed]), hardline] : [printed] : [printed, hardline]);
}
function isFormatLikeCall(node) {
  if (is_Identifier(node.callee) && !node.typeArguments) {
    const [first, ...rest] = node.arguments;
    if (is_Literal(first) && is_LiteralStringLike(first) && first.value.includes("{}") && rest.every(is_Identifier)) {
      return true;
    }
  }
  return false;
}
var ArgExpansionBailout = class extends Error {
};
function printCallArguments(print4, node) {
  const args = node.arguments;
  const { left: LEFT, right: RIGHT } = getDelimChars(args);
  if (args.length === 0)
    return [LEFT, printDanglingCommentsForInline(node, "arguments" /* arguments */), RIGHT];
  if (args.length === 2 && isFormatLikeCall(node)) {
    return [LEFT, print4(["arguments", 0]), ", ", print4(["arguments", 1]), RIGHT];
  }
  let anyArgEmptyLine = false;
  let hasEmptyLineFollowingFirstArg = false;
  const lastArgIndex = args.length - 1;
  const trailingComma = "";
  const printedArguments = print4.map("arguments", (arg, index, arr) => {
    if (index === lastArgIndex) {
      return [print4()];
    } else if (isNextLineEmpty(arg)) {
      if (index === 0)
        hasEmptyLineFollowingFirstArg = true;
      anyArgEmptyLine = true;
      return [print4(), ",", hardline, hardline];
    } else {
      return [print4(), ",", line];
    }
  });
  if (anyArgEmptyLine || isFunctionCompositionArgs(args)) {
    return allArgsBrokenOut();
  }
  const shouldGroupFirst = shouldGroupFirstArg(args);
  const shouldGroupLast = shouldGroupLastArg(args);
  if (shouldGroupFirst || shouldGroupLast) {
    if (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) {
      return allArgsBrokenOut();
    }
    let printedExpanded = [];
    const { path } = getContext();
    const stackBackup = [...path.stack];
    try {
      path_try(() => {
        getContext().path.each((p, i) => {
          if (shouldGroupFirst && i === 0) {
            printedExpanded = [
              [
                print4([], { expandFirstArg: true }),
                printedArguments.length > 1 ? "," : "",
                hasEmptyLineFollowingFirstArg ? hardline : line,
                hasEmptyLineFollowingFirstArg ? hardline : ""
              ],
              ...printedArguments.slice(1)
            ];
          }
          if (shouldGroupLast && i === lastArgIndex) {
            printedExpanded = [...printedArguments.slice(0, -1), print4([], { expandLastArg: true })];
          }
        }, "arguments");
      });
    } catch (caught) {
      path.stack.length = 0;
      path.stack.push(...stackBackup);
      if (caught instanceof ArgExpansionBailout)
        return allArgsBrokenOut();
      throw caught;
    }
    return [
      printedArguments.some(willBreak) ? breakParent : "",
      conditionalGroup([
        [LEFT, ...printedExpanded, RIGHT],
        shouldGroupFirst ? [LEFT, group(printedExpanded[0], { shouldBreak: true }), ...printedExpanded.slice(1), RIGHT] : [LEFT, ...printedArguments.slice(0, -1), group(printedExpanded[lastArgIndex], { shouldBreak: true }), RIGHT],
        allArgsBrokenOut()
      ])
    ];
  }
  const contents = [LEFT, indent([softline, ...printedArguments]), ifBreak(trailingComma), softline, RIGHT];
  return isLongCurriedCallExpression(node) ? contents : group(contents, { shouldBreak: anyArgEmptyLine || printedArguments.some(willBreak) });
  function allArgsBrokenOut() {
    return group([LEFT, indent([line, ...printedArguments]), trailingComma, line, RIGHT], { shouldBreak: true });
  }
}
function shouldHugFunctionParameters(node) {
  if (!node)
    return false;
  const parameters = getParameters(node);
  if (parameters.length !== 1)
    return false;
  const param = parameters[0];
  if (hasComment(param))
    return false;
  switch (param.nodeType) {
    case NodeType.FunctionSelfParameterDeclaration:
    case NodeType.FunctionSpread:
    case NodeType.TypeFnPointerParameter:
    default:
      return false;
    case NodeType.FunctionParameterDeclaration:
    case NodeType.ClosureFunctionParameterDeclaration:
      return "items" in param.pattern || "properties" in param.pattern;
  }
}
function shouldGroupFunctionParameters(functionNode, returnTypeDoc) {
  const returnType = functionNode.returnType;
  const generics = functionNode.generics;
  const whereBounds = functionNode.whereBounds;
  if (!returnType)
    return false;
  if (generics) {
    if (generics.length > 1)
      return false;
    if (generics.length === 1 && !isShortGenericParameterDeclaration(generics[0]))
      return false;
  }
  if (whereBounds) {
    if (whereBounds.length > 1)
      return false;
  }
  return getParameters(functionNode).length === 1 && (willBreak(returnTypeDoc) || willBreak(printWhereBounds(getPrintFn(), functionNode)));
}
function printBlockBody(print4, node) {
  var _a;
  const body = printBodyOrCases(print4, node);
  return [
    "{",
    body.length > 0 ? ((_a = getBodyOrCases(node)) == null ? void 0 : _a.length) ? canInlineBlockBody(node) ? [indent([line, body]), line] : group([indent([line, body]), line], { shouldBreak: true }) : body : emptyContent(node),
    "}"
  ];
}
function printMaybeBlockBody(print4, node) {
  return hasSemiNoBody(node) ? ";" : adjustClause(node, printBlockBody(print4, node));
}
function printArrowFunction(print4, node) {
  const signatures = [];
  const body = [];
  const { args, path } = getContext();
  let chainShouldBreak = false;
  let tailNode = node;
  (function rec(node2) {
    tailNode = node2;
    const doc2 = printArrowFunctionSignature(print4, node2);
    if (signatures.length === 0) {
      signatures.push(doc2);
    } else {
      const { leading, trailing } = printCommentsSeparately();
      signatures.push([leading, doc2]);
      body.unshift(trailing);
    }
    chainShouldBreak || (chainShouldBreak = !!node2.returnType || !node2.parameters.every((param) => isSimplePattern(param.pattern)));
    if (!is_ClosureFunctionExpression(node2.expression) || args && args.expandLastArg) {
      body.unshift(print4("expression", args));
    } else {
      pathCall(node2, "expression", rec);
    }
  })(node);
  if (signatures.length > 1) {
    return printArrowChain(signatures, chainShouldBreak, body, tailNode);
  } else {
    const printed = signatures[0];
    if (!hasLeadingOwnLineComment(node.expression) && (is_ArrayOrTupleLiteral(node.expression) || is_StructLiteral(node.expression) || is_ExpressionWithBodyOrCases(node.expression) || is_ClosureFunctionExpression(node.expression))) {
      return group([printed, " ", body]);
    }
    const shouldAddSoftLine = args && args.expandLastArg && !hasComment(node);
    const printTrailingComma = args && args.expandLastArg && false;
    const shouldAddParens = is_OrExpression(node.expression);
    return group([
      printed,
      group([
        indent(shouldAddParens ? [line, ifBreak("", "("), body, ifBreak("", ")")] : [line, body]),
        shouldAddSoftLine ? [ifBreak(printTrailingComma ? "," : ""), softline] : ""
      ])
    ]);
  }
}
function printArrowChain(signatures, shouldBreak, bodyDoc, tailNode) {
  const { args } = getContext();
  const parent = getParentNode();
  const isCallee = is_CallExpression_or_CallLikeMacroInvocation(parent) && parent.callee === getNode();
  const isAssignmentRhs = !!(args && args.assignmentLayout);
  const shouldPutBodyOnSeparateLine = !is_ExpressionWithBodyOrCases(tailNode.expression) && !is_StructLiteral(tailNode.expression);
  const shouldBreakBeforeChain = isCallee && shouldPutBodyOnSeparateLine || args && args.assignmentLayout === 6 /* chain-tail-arrow-chain */;
  const groupId = Symbol("arrow-chain");
  return group([
    group(
      indent([isCallee || isAssignmentRhs ? softline : "", group(join(line, signatures), { shouldBreak })]),
      { id: groupId, shouldBreak: shouldBreakBeforeChain }
    ),
    indentIfBreak(shouldPutBodyOnSeparateLine ? indent([line, bodyDoc]) : [" ", bodyDoc], { groupId }),
    isCallee ? ifBreak(softline, "", { groupId }) : ""
  ]);
}
function printArrowFunctionSignature(print4, node) {
  const { args } = getContext();
  const expandArg = args && (args.expandLastArg || args.expandFirstArg);
  let returnTypeDoc = printReturnType(print4, node);
  if (expandArg) {
    if (willBreak(returnTypeDoc))
      throw new ArgExpansionBailout();
    else
      returnTypeDoc = group(removeLines(returnTypeDoc));
  }
  return [
    print4.b("static"),
    print4.b("async"),
    print4.b("move"),
    group([printFunctionParameters(print4, node, expandArg), returnTypeDoc])
  ];
}
function printGenerics_x_whereBounds(print4, node, xDoc) {
  const generics = is_ImplDeclarationNode(node) ? [printGenerics(print4, node), " "] : [" ", print4("id"), printGenerics(print4, node)];
  const whereBoundsDoc = printWhereBounds(print4, node);
  return is_TupleStructDeclaration(node) ? [...generics, xDoc, group(whereBoundsDoc, { id: getHeritageGroupId(node) })] : [...generics, group([xDoc, whereBoundsDoc], { id: getHeritageGroupId(node) })];
}
function adjustClause(node, doc2) {
  return [
    "whereBounds" in node && (!!node.whereBounds || hasTypeBounds(node) && node.typeBounds.length > 1) && willBreak(doc2) ? ifBreak(hardline, " ", { groupId: getHeritageGroupId(node) }) : " ",
    doc2
  ];
}
function printParametersAndReturnType(node) {
  const parametersDoc = printFunctionParameters(getPrintFn(), node);
  const returnTypeDoc = printReturnType(getPrintFn(), node);
  return is_FunctionDeclaration(node) && shouldGroupFunctionParameters(node, returnTypeDoc) ? group([group(parametersDoc), returnTypeDoc]) : group([parametersDoc, returnTypeDoc]);
}
function printFlowControlExpression(print4, node) {
  return !node.expression ? "" : is_BinaryishExpression(node.expression) && !flowControlExpressionNeedsOuterParens(node) ? group([" ", ifBreak("("), indent([softline, print4("expression")]), softline, ifBreak(")")]) : [" ", print4("expression")];
}
function flowControlExpressionNeedsOuterParens(flow) {
  return flow.expression && function hasLeadingComment(node) {
    if (hasLeadingOwnLineComment(node))
      return true;
    if (hasNakedLeftSide(node)) {
      let leftMost = node;
      while (leftMost = getLeftSide(leftMost)) {
        if (hasLeadingOwnLineComment(leftMost))
          return true;
      }
    }
    return false;
  }(flow.expression);
}
function getLeftSide(node, includeAttributes = false) {
  let target = node.left ?? node.callee ?? node.namespace ?? node.label ?? node.lower ?? node.struct ?? node.condition ?? node.expression;
  if (target && includeAttributes && hasAttributes(node)) {
    node.attributes.forEach((attr) => {
      if (start(attr) < start(target))
        target = attr;
    });
  }
  return target;
}
function hasNakedLeftSide(node) {
  return is_BinaryishExpression(node) || is_ReassignmentNode(node) || is_CallExpression_or_CallLikeMacroInvocation(node) || is_MemberAccessLike(node) || is_PostfixExpression(node) || is_ExpressionAsTypeCast(node);
}
function printReturnType(print4, node) {
  return node.returnType ? is_FunctionDeclaration(node) ? adjustDeclarationClause(node, "->", print4("returnType")) : [" -> ", print4("returnType")] : "";
}
function printFunctionParameters(print4, node, expandArg = false, printTypeParams = false) {
  const { left: leftDelim, right: rightDelim } = getDelimChars(node.parameters);
  const generics = printTypeParams && is_FunctionDeclaration(node) ? printGenerics(print4, node) : "";
  if (!hasParameters(node)) {
    return [
      generics,
      leftDelim,
      printDanglingCommentsForInline(node, "parameters" /* parameters */),
      rightDelim
    ];
  }
  const isParametersInTestCall = false;
  const shouldHugParameters = shouldHugFunctionParameters(node);
  const printed = print4.join("parameters", sepFn);
  if (hasSelfParameter(node)) {
    printed.unshift(getContext().path.call(() => [print4(), printed.length ? sepFn(node.parameters.self) : ""], "parameters", "self"));
  }
  if (expandArg) {
    if (willBreak(generics) || willBreak(printed))
      throw new ArgExpansionBailout();
    return group([removeLines(generics), leftDelim, removeLines(printed), rightDelim]);
  } else if (shouldHugParameters || isParametersInTestCall) {
    return [generics, leftDelim, ...printed, rightDelim];
  } else {
    return [generics, leftDelim, indent([softline, ...printed]), softline, rightDelim];
  }
  function sepFn(param) {
    return shouldHugParameters || isParametersInTestCall ? ", " : isNextLineEmpty(param) ? [",", hardline, hardline] : [",", line];
  }
}
function path_try(callback) {
  const { stack } = getContext().path;
  const stackBackup = [...stack];
  try {
    return callback();
  } finally {
    stack.length = 0;
    stack.push(...stackBackup);
  }
}
function shouldGroupFirstArg(args) {
  if (args.length !== 2)
    return false;
  const [firstArg, secondArg] = args;
  return !hasComment(firstArg) && is_ClosureFunctionExpression(firstArg) && is_ExpressionWithBodyOrCases(firstArg.expression) && !is_ClosureFunctionExpression(secondArg) && !couldGroupArg(secondArg);
}
function shouldGroupLastArg(args) {
  const lastArg = last_of(args);
  const preLastArg = args[args.length - 2];
  return !hasComment(lastArg, 2 /* Leading */) && !hasComment(lastArg, 4 /* Trailing */) && couldGroupArg(lastArg) && (!preLastArg || preLastArg.nodeType !== lastArg.nodeType) && (args.length !== 2 || !is_ClosureFunctionExpression(preLastArg) || !is_ArrayOrTupleLiteral(lastArg)) && !(args.length > 1 && is_ArrayOrTupleLiteral(lastArg) && isConciselyPrintedArray(lastArg)) && (args.length !== 1 || !is_IfBlockExpression(lastArg));
}
function couldGroupArg(arg, arrowChainRecursion = false) {
  return is_StructLiteral(arg) && (arg.properties.length > 0 || hasComment(arg)) || is_ArrayOrTupleLiteral(arg) && (arg.items.length > 0 || hasComment(arg)) || is_ExpressionAsTypeCast(arg) && couldGroupArg(arg.expression) || is_ClosureFunctionExpression(arg) && (!arg.returnType || is_Identifier(arg.returnType) || !isNonEmptyBlockStatement(arg.expression)) && (isNonEmptyBlockStatement(arg.expression) || is_ClosureFunctionExpression(arg.expression) && couldGroupArg(arg.expression, true) || is_StructLiteral(arg.expression) || is_ArrayOrTupleLiteral(arg.expression) || !arrowChainRecursion && is_CallExpression_or_CallLikeMacroInvocation(arg.expression)) || is_ExpressionWithBodyOrCases(arg);
}
function isNonEmptyBlockStatement(node) {
  if (is_MatchExpression(node))
    return node.cases.length > 0;
  return is_ExpressionWithBodyOrCases(node) && node.body.length > 0;
}
function isFunctionCompositionArgs(args) {
  if (args.length <= 1) {
    return false;
  }
  let count = 0;
  for (const arg of args) {
    if (is_ClosureFunctionExpression(arg)) {
      if (++count > 1)
        return true;
    } else if (is_CallExpression_or_CallLikeMacroInvocation(arg)) {
      for (const childArg of arg.arguments) {
        if (is_ClosureFunctionExpression(childArg)) {
          return true;
        }
      }
    }
  }
  return false;
}
function printBinaryishExpression(print4, node) {
  const parent = getParentNode();
  const grandParent = getGrandParentNode();
  const isInsideParenthesis = "condition" in parent && parent.condition === node || is_MatchExpression(parent);
  const parts = printBinaryishExpressions(false, isInsideParenthesis);
  if (isInsideParenthesis)
    return parts;
  if (is_CallExpression_or_CallLikeMacroInvocation(parent) && parent.callee === node || is_UnaryExpression(parent) || is_MemberExpression(parent)) {
    return group([indent([softline, ...parts]), softline]);
  }
  const shouldNotIndent = is_FlowControlExpression(parent) || is_ClosureFunctionExpression(parent) && parent.expression === node || is_ExpressionWithBodyOrCases(parent);
  const shouldIndentIfInlining = is_ReassignmentNode(parent) || is_VariableDeclarationNode(parent) || is_StructLiteral(parent) || is_StructLiteral(grandParent);
  const samePrecedenceSubExpression = is_BinaryishExpression(node.left) && shouldFlatten(node, node.left);
  if (shouldNotIndent || shouldInlineLogicalExpression(node) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(node) && shouldIndentIfInlining) {
    return group(parts);
  }
  if (parts.length === 0)
    return "";
  const firstGroupIndex = parts.findIndex((part) => typeof part !== "string" && !Array.isArray(part) && part.type === "group");
  const leading = parts.slice(0, firstGroupIndex === -1 ? 1 : firstGroupIndex + 1);
  return group([...leading, indent(parts.slice(leading.length))], { id: Symbol("logicalChain") });
  function printBinaryishExpressions(isNested, isInsideParenthesis2) {
    const { path, print: print5, options: options2 } = getContext();
    const node2 = path.getValue();
    if (!is_BinaryishExpression(node2)) {
      return [group(print5())];
    }
    const parts2 = [];
    if (shouldFlatten(node2, node2.left)) {
      parts2.push(...pathCall(node2, "left", () => printBinaryishExpressions(true, isInsideParenthesis2)));
    } else {
      parts2.push(group(print5("left")));
    }
    const shouldInline = shouldInlineLogicalExpression(node2);
    const operator = node2.kind;
    const right = [
      operator,
      shouldInline ? " " : line,
      !shouldInline && is_LogicalExpression(node2.right) && shouldFlatten(node2.right, node2) ? pathCall(node2, "right", () => printBinaryishExpressions(true, isInsideParenthesis2)) : print5("right")
    ];
    const shouldBreak = hasComment(node2.left, 4 /* Trailing */ | 32 /* Line */);
    const shouldGroup = shouldBreak || !(isInsideParenthesis2 && is_LogicalExpression(node2)) && path.getParentNode().nodeType !== node2.nodeType && node2.left.nodeType !== node2.nodeType && node2.right.nodeType !== node2.nodeType;
    parts2.push(" ", shouldGroup ? group(right, { shouldBreak }) : right);
    if (isNested && hasComment(node2)) {
      const printed = cleanDoc(withComments(node2, parts2));
      if (isConcat(printed) || printed.type === "fill") {
        return getDocParts(printed);
      }
      return [printed];
    }
    return parts2;
  }
}
function shouldInlineLogicalExpression(node) {
  if (is_LogicalExpression(node)) {
    if (is_StructLiteral(node.right))
      return node.right.properties.length > 0;
    if (is_ArrayOrTupleLiteral(node.right))
      return node.right.items.length > 0;
  }
  return false;
}
function printUnaryExpression(leftDoc, node) {
  const printed = getPrintFn()("expression");
  return group([leftDoc, printed]);
}
function printIfBlock(print4, node) {
  let printed = [
    printIfBlockCondition(print4, node),
    printBlockBody(print4, node),
    f` else ${print4("else")}`
  ];
  const parent = getParentNode();
  if (is_ClosureBlock(node, parent)) {
    printed = parenthesize_if_break([indent([softline, printed]), softline]);
  } else if (!is_ElseBlock(node, parent)) ;
  return printed;
}
function printIfBlockCondition(print4, node) {
  if (!hasCondition(node))
    return "";
  return f`if ${printCondition(print4, node)}`;
}
function printCondition(print4, node) {
  return pathCall(node, "condition", (condition) => {
    if (!condition)
      return "";
    if (needsParens(condition))
      return [print4(), " "];
    const id = Symbol("condition");
    const printed = [indent([softline , print4()]), softline];
    return [group(printed, { id }), ifBreak("", " ", { groupId: id })];
  });
}
function parenthesize_if_break(doc2) {
  return conditionalGroup([doc2, ["(", doc2, ")"]], { shouldBreak: willBreak(doc2) });
}
function isSimplePattern(node) {
  if (!node)
    return false;
  switch (node.nodeType) {
    case NodeType.MacroInvocation:
      return false;
    case NodeType.ExpressionTypeCast:
      return isSimplePattern(node.typeCallee) && !hasComplexTypeArguments(node);
    case NodeType.ExpressionTypeSelector:
      return is_Identifier(node.typeTarget) && (!node.typeExpression || is_Identifier(node.typeExpression));
    case NodeType.ExpressionPath:
      return !node.namespace || isSimplePattern(node.namespace);
    case NodeType.RangePattern:
      return (!node.lower || isSimplePattern(node.lower)) && (!node.upper || isSimplePattern(node.upper));
    case NodeType.PatternVariableDeclaration:
    case NodeType.ReferencePattern:
    case NodeType.BoxPattern:
    case NodeType.MinusPattern:
      return isSimplePattern(node.pattern);
    case NodeType.Identifier:
    case NodeType.Literal:
    case NodeType.RestPattern:
    case NodeType.WildcardPattern:
      return true;
    default:
      return false;
  }
}
function printUnionPattern(print4, node) {
  if (node.patterns.length === 1)
    return print4.map("patterns");
  const parent = getParentNode();
  const prebreak = parent && (is_VariableDeclarationNode(parent) || is_LetScrutinee(parent)) && !needsParens(node);
  return group([
    prebreak ? softline : "",
    print4.map("patterns", (node2, i, arr) => [
      withComments(node2, [
        i === 0 ? ifBreak("| ") : "| ",
        align(2, print4())
      ]),
      i === arr.length - 1 ? "" : line
    ])
  ]);
}
function printArrayLike(print4, node) {
  const delims = getDelimChars(node.items);
  if (node.items.length === 0) {
    const comments = printDanglingCommentsForInline(node, "items" /* items */);
    return comments ? group([delims.left, comments, delims.right]) : delims.left + delims.right;
  }
  const groupId = Symbol("array");
  const shouldBreak = !is_TupleNode(node) && node.items.length > 1 && node.items.every((item, i) => {
    const next = node.items[i + 1];
    return (hasProperties(item) && item.properties.length > 1 || hasItems(item) && item.items.length > 1) && (!next || item.nodeType === next.nodeType);
  });
  const shouldUseConciseFormatting = isConciselyPrintedArray(node);
  const parent = getParentNode();
  const needsForcedTrailingComma = node.items.length === 1 ? is_TupleLiteral(node) ? is_RangeLiteral(node.items[0]) ? !(is_ReassignmentExpression(parent) && parent.left === node) : true : is_TuplePattern(node) ? !node.struct && !is_RangePattern(node.items[0]) && !is_RestPattern(node.items[0]) : is_TypeTuple(node) ? true : false : false;
  const trailingComma = needsForcedTrailingComma ? "," : shouldUseConciseFormatting ? ifBreak(",", "", { groupId }) : ifBreak(",");
  const printed = shouldUseConciseFormatting ? fill(
    print4.join(
      "items",
      (item, next) => isNextLineEmpty(item) ? [",", hardline, hardline] : hasComment(next, 2 /* Leading */, (comment) => is_LineCommentNode(comment) || comment.placement === "ownLine") ? [",", hardline] : [",", line],
      trailingComma
    )
  ) : print4.map_join(
    "items",
    () => group(print4()),
    (item) => isNextLineEmpty(item) ? [",", line, softline] : [",", line],
    trailingComma
  );
  return group([delims.left, indent([softline, printed]), printDanglingComments(node, true, "items" /* items */), softline, delims.right], {
    shouldBreak,
    id: groupId
  });
}
function printObject(print4, node) {
  if (hasSemiNoProperties(node)) {
    return ";";
  }
  if (!hasProperties(node)) {
    return [" {", printDanglingCommentsForInline(node, "properties" /* properties */) || emptyContent(node), "}"];
  }
  const firstProperty = node.properties[0];
  const parent = getParentNode();
  const shouldBreak = is_StructPattern(node) ? false : is_UnionDeclaration(node) || is_StructDeclaration(node) || is_EnumMemberStructDeclaration(node) || hasNewlineInRange(start(node), start(firstProperty));
  const content = [
    " {",
    indent([
      line,
      ...print4.join(
        "properties",
        (node2) => isNextLineEmpty(node2) ? [",", hardline, hardline] : [",", line],
        (node2) => is_StructSpread(node2) ? "" : ifBreak(",")
      )
    ]),
    line,
    "}"
  ];
  const grandparent = getGrandParentNode();
  if (grandparent && (is_FunctionDeclaration(grandparent) || is_ClosureFunctionExpression(grandparent)) && getParameters(grandparent)[0] === parent) {
    return content;
  }
  if (is_StructLiteral(node) && is_ReassignmentNode(parent) && parent.left === node || is_StructPattern(node) && (is_VariableDeclarationNode(parent) || is_MatchExpressionCase(parent) || is_FunctionParameterDeclaration(parent)) && parent.pattern === node) {
    return content;
  }
  return group(content, { shouldBreak });
}
function printEnumBody(print4, node) {
  const printed = print4.join("members", (member) => [",", maybeEmptyLine(member)], ",");
  return [
    " {",
    printed.length === 0 ? printDanglingCommentsForInline(node, "members" /* members */) || emptyContent(node) : [indent([hardline, ...printed]), hardline],
    "}"
  ];
}

// src/format/comments.ts
function addCommentHelper(node, comment, leading = false, trailing = false) {
  (node.comments ?? (node.comments = [])).push(comment);
  comment.leading = leading, comment.trailing = trailing, comment.printed = false;
}
function addLeadingComment(node, comment) {
  addCommentHelper(node, comment, true);
}
function addDanglingComment(node, comment, marker) {
  addCommentHelper(node, comment);
  comment.marker = marker;
}
function addTrailingComment(node, comment) {
  addCommentHelper(node, comment, false, true);
}
function setPrettierIgnoreTarget(node, comment) {
  comment.unignore = true;
  node.prettierIgnore = true;
}
function hasComments(node) {
  return "comments" in node && node.comments.length > 0;
}
function printDanglingComments(enclosingNode, sameIndent, marker) {
  if (hasComments(enclosingNode)) {
    const printed = [];
    pathCallEach(enclosingNode, "comments", (comment) => {
      if (isDangling(comment) && (!marker || comment.marker === marker)) {
        printed.push(printComment(comment));
      }
    });
    if (printed.length > 0) {
      return sameIndent ? join(hardline, printed) : indent([hardline, join(hardline, printed)]);
    }
  }
  return "";
}
function setDidPrintComment(comment) {
  comment.printed = true;
}
function printComment(comment) {
  setDidPrintComment(comment);
  return getContext().options.printer.printComment(getContext().path, getOptions());
}
function isPreviousLineEmpty(node) {
  let index = start(node) - 1;
  index = skipSpaces(index, true);
  index = skipNewline(index, true);
  index = skipSpaces(index, true);
  return index !== skipNewline(index, true);
}
function hasBreaklineBefore(node) {
  return hasNewline(start(node) - 1, true);
}
function hasBreaklineAfter(node) {
  return hasNewline(end(node));
}
function printCommentsSeparately(ignored) {
  const node = getNode();
  const leading = [];
  const trailing = [];
  let hasTrailingLineComment = false;
  let hadLeadingBlockComment = false;
  if ("comments" in node) {
    pathCallEach(node, "comments", (comment) => {
      if (ignored == null ? void 0 : ignored.has(comment)) {
        return;
      } else if (isLeading(comment)) {
        leading.push(printLeadingComment(comment));
      } else if (isTrailing(comment)) {
        trailing.push(printTrailingComment(comment));
      }
    });
  }
  if (node === getOptions().cursorNode) {
    leading.unshift(cursor);
    trailing.push(cursor);
  }
  return (leading.length | trailing.length) > 0 ? { leading, trailing } : { leading: "", trailing: "" };
  function printLeadingComment(comment) {
    if (is_Attribute(comment) && !comment.inner) {
      const printed = printComment(comment);
      return [printed, " "];
    }
    hadLeadingBlockComment || (hadLeadingBlockComment = is_BlockCommentKind(comment) && hasBreaklineBefore(comment));
    return [
      printComment(comment),
      is_BlockCommentKind(comment) ? hasBreaklineAfter(comment) ? hadLeadingBlockComment ? hardline : line : " " : hardline,
      hasNewline(skipNewline(skipSpaces(end(comment)))) ? hardline : ""
    ];
  }
  function printTrailingComment(comment) {
    const printed = printComment(comment);
    return hasBreaklineBefore(comment) ? lineSuffix([hardline, isPreviousLineEmpty(comment) ? hardline : "", printed]) : is_BlockCommentNode(comment) ? [" ", printed] : lineSuffix([" ", printed, hasTrailingLineComment === (hasTrailingLineComment = true) ? hardline : breakParent]);
  }
}
function getPostLeadingComment(comment) {
  return hasNewline(skipNewline(skipSpaces(end(comment)))) ? hardline : "";
}
function withComments(node, printed, ignored) {
  const { leading, trailing } = printCommentsSeparately(ignored);
  return leading || trailing ? [...leading, printed, ...trailing] : printed;
}
function getComments(node, ...args) {
  return node && node.comments ? args.length > 0 ? node.comments.filter(getCommentTestFunction(...args)) : node.comments : [];
}
function getFirstComment(node, flags, fn) {
  const r = getComments(node, flags | CF.First, fn);
  return r.length === 0 ? void 0 : r[0];
}
function escapeComments(flags, fn) {
  const comments = getAllComments().filter(getCommentTestFunction(flags, fn));
  comments.forEach(setDidPrintComment);
  return new Set(comments);
}
var CF = /* @__PURE__ */ ((CF2) => {
  CF2[CF2["Leading"] = 2] = "Leading";
  CF2[CF2["Trailing"] = 4] = "Trailing";
  CF2[CF2["Dangling"] = 8] = "Dangling";
  CF2[CF2["Block"] = 16] = "Block";
  CF2[CF2["Line"] = 32] = "Line";
  CF2[CF2["PrettierIgnore"] = 64] = "PrettierIgnore";
  CF2[CF2["First"] = 128] = "First";
  CF2[CF2["Last"] = 256] = "Last";
  return CF2;
})(CF || {});
function isPrettierIgnoreComment(comment) {
  return is_Comment(comment) && /^\s*prettier-ignore\s*/.test(comment.value) && !comment.unignore;
}
function isPrettierIgnoreAttribute(node) {
  return is_Attribute(node) && /^\s*rustfmt::skip\s*$/.test(node.value);
}
function getCommentTestFunction(flags, fn) {
  return function(comment, index, comments) {
    return !(flags & 2 /* Leading */ && !isLeading(comment) || flags & 4 /* Trailing */ && !isTrailing(comment) || flags & 8 /* Dangling */ && !isDangling(comment) || flags & 16 /* Block */ && !is_BlockCommentKind(comment) || flags & 32 /* Line */ && !is_LineCommentKind(comment) || flags & 128 /* First */ && index !== 0 || flags & 256 /* Last */ && !iLast(index, comments) || flags & 64 /* PrettierIgnore */ && !(isPrettierIgnoreComment(comment) || isPrettierIgnoreAttribute(comment)) || fn && !fn(comment));
  };
}
function hasComment(node, flags = 0, fn) {
  if ("comments" in node && node.comments.length > 0) {
    return flags || fn ? node.comments.some(getCommentTestFunction(flags, fn)) : true;
  }
  return false;
}
function hasNewlineInRange(leftIndex, rightIndex) {
  const text = getContext().options.originalText;
  for (var i = leftIndex; i < rightIndex; ++i)
    if (text.charCodeAt(i) === 10)
      return true;
  return false;
}
function isNextLineEmpty(node) {
  return isNextLineEmptyAfterIndex(end(node));
}
function isNextLineEmptyAfterIndex(index) {
  let oldIdx = -1;
  let idx = index;
  while (idx !== oldIdx) {
    oldIdx = idx;
    idx = skipToLineEnd(idx);
    idx = skipBlockComment(idx);
    idx = skipSpaces(idx);
    idx = skipParens(idx);
  }
  idx = skipLineComment(idx);
  idx = skipParens(idx);
  idx = skipNewline(idx);
  idx = skipParens(idx);
  return idx !== false && hasNewline(idx);
}
function hasNewline(index, backwards = false) {
  if (index === false)
    return false;
  const i = skipSpaces(index, backwards);
  return i !== false && i !== skipNewline(i, backwards);
}
function skipLineComment(index) {
  if (index === false)
    return false;
  const { commentSpans, originalText } = getContext().options;
  if (commentSpans.has(index) && originalText.charCodeAt(index + 1) === 47)
    return skipEverythingButNewLine(commentSpans.get(index));
  return index;
}
function skipBlockComment(index) {
  if (index === false)
    return false;
  const { commentSpans, originalText } = getContext().options;
  if (commentSpans.has(index) && originalText.charCodeAt(index + 1) === 42)
    return commentSpans.get(index);
  return index;
}
var [skipSpaces, skipToLineEnd, skipEverythingButNewLine] = [/[ \t]/, /[,; \t]/, /[^\r\n]/].map(function(re) {
  return function(index, backwards = false) {
    if (index === false)
      return false;
    const { originalText: text } = getContext().options;
    let cursor2 = index;
    while (cursor2 >= 0 && cursor2 < text.length) {
      if (re.test(text.charAt(cursor2)))
        backwards ? cursor2-- : cursor2++;
      else
        return cursor2;
    }
    return cursor2 === -1 || cursor2 === text.length ? cursor2 : false;
  };
});
function skipNewline(index, backwards = false) {
  if (index === false)
    return false;
  const { originalText } = getContext().options;
  const atIndex = originalText.charCodeAt(index);
  if (backwards) {
    if (originalText.charCodeAt(index - 1) === 13 && atIndex === 10)
      return index - 2;
    if (atIndex === 10)
      return index - 1;
  } else {
    if (atIndex === 13 && originalText.charCodeAt(index + 1) === 10)
      return index + 2;
    if (atIndex === 10)
      return index + 1;
  }
  return index;
}
function skipParens(index, backwards = false) {
  return index;
}
function getNextNonSpaceNonCommentCharacterIndex(node) {
  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(end(node));
}
function getNextNonSpaceNonCommentCharacterIndexWithStartIndex(i) {
  let oldIdx = -1;
  let nextIdx = i;
  while (nextIdx !== oldIdx) {
    oldIdx = nextIdx;
    nextIdx = skipSpaces(nextIdx);
    nextIdx = skipBlockComment(nextIdx);
    nextIdx = skipLineComment(nextIdx);
    nextIdx = skipNewline(nextIdx);
    nextIdx = skipParens(nextIdx);
  }
  return nextIdx;
}
function handled(comment) {
  return "printed" in comment;
}
function handleCommon(ctx2) {
  {
    const { comment: comment2, precedingNode: precedingNode2, enclosingNode, followingNode: followingNode2 } = ctx2;
    if (!enclosingNode) {
      ctx2.enclosingNode = ctx2.comment.loc.src.program;
    } else if (enclosingNode && is_NodeWithBodyOrCases(enclosingNode)) {
      const body = getBodyOrCases(enclosingNode);
      if (body) {
        if (is_ExpressionWithBodyOrCases(enclosingNode) && enclosingNode.label) {
          if (ctx2.precedingNode === enclosingNode.label) {
            ctx2.precedingNode = void 0;
          }
          if (followingNode2 === enclosingNode.label) {
            ctx2.followingNode = void 0;
          }
        }
        if (comment2.loc.isBefore(body)) {
          if (followingNode2 && body.loc.contains(followingNode2)) {
            ctx2.followingNode = void 0;
          }
          if (!ctx2.precedingNode && !ctx2.followingNode) {
            addLeadingComment(enclosingNode, comment2);
            return true;
          }
        } else if (comment2.loc.isAfter(body)) {
          if (precedingNode2 && body.loc.contains(precedingNode2)) {
            ctx2.precedingNode = void 0;
          }
          if (!ctx2.precedingNode && !ctx2.followingNode) {
            addTrailingComment(enclosingNode, comment2);
            return true;
          }
        } else if (body.loc.contains(comment2)) {
          if (precedingNode2 && !body.loc.contains(precedingNode2)) {
            ctx2.precedingNode = void 0;
          }
          if (followingNode2 && !body.loc.contains(followingNode2)) {
            ctx2.followingNode = void 0;
          }
        }
      }
    }
  }
  for (const fn of [
    handleMixedInOuterAttributeComments,
    handleAttributeComments,
    handleDanglingComments,
    handleFunctionComments,
    handleMacroRuleComments,
    handleStructLiteralComments,
    handleVariableDeclaratorComments,
    handleIfBlockExpressionComments,
    handleMemberExpressionComments,
    handleStatementComments,
    handleFlowControlComments,
    handleBadComments
  ]) {
    fn(ctx2);
    if (handled(ctx2.comment)) {
      return true;
    }
  }
  const { precedingNode, followingNode, comment } = ctx2;
  if (isStartOfLine(comment)) {
    if (followingNode) {
      addLeadingComment(followingNode, comment);
    } else if (precedingNode) {
      addTrailingComment(precedingNode, comment);
    } else {
      exit.never(ctx2);
    }
  } else if (isEndOfLine(comment)) {
    if (precedingNode) {
      addTrailingComment(precedingNode, comment);
    } else if (followingNode) {
      addLeadingComment(followingNode, comment);
    } else {
      exit.never(ctx2);
    }
  } else {
    if (precedingNode && followingNode) {
      return false;
    } else if (precedingNode) {
      addTrailingComment(precedingNode, comment);
    } else if (followingNode) {
      addLeadingComment(followingNode, comment);
    } else {
      exit.never(ctx2);
    }
  }
  return handled(ctx2.comment);
}
function handleOwnLineComment(ctx2) {
  return handleCommon(ctx2);
}
function handleEndOfLineComment(ctx2) {
  const { precedingNode, enclosingNode, comment } = ctx2;
  if (precedingNode && enclosingNode && is_CallExpression_or_CallLikeMacroInvocation(enclosingNode) && enclosingNode.arguments.length > 0 && precedingNode === (enclosingNode.typeArguments ? last_of(enclosingNode.typeArguments) : enclosingNode.callee)) {
    addLeadingComment(enclosingNode.arguments[0], comment);
    return true;
  } else if (enclosingNode && is_StructLiteralProperty(enclosingNode)) {
    addLeadingComment(enclosingNode, comment);
    return true;
  } else {
    return handleCommon(ctx2);
  }
}
function handleRemainingComment(ctx2) {
  return handleCommon(ctx2);
}
function handleStructLiteralComments({ enclosingNode, followingNode, comment }) {
  if (enclosingNode && is_StructLiteralPropertySpread(enclosingNode) && followingNode === enclosingNode.expression) {
    addLeadingComment(enclosingNode, comment);
  }
}
function handleVariableDeclaratorComments({ enclosingNode, followingNode, comment }) {
  if (enclosingNode && (is_xVariableEqualishLike(enclosingNode) || is_ReassignmentNode(enclosingNode)) && followingNode && (is_BlockCommentKind(comment) || nisAnyOf(followingNode, [
    NodeType.StructLiteral,
    NodeType.StructPattern,
    NodeType.TupleLiteral,
    NodeType.TypeTuple,
    NodeType.TuplePattern,
    NodeType.ArrayLiteral,
    NodeType.ArrayPattern,
    NodeType.SizedArrayLiteral,
    NodeType.TypeSizedArray
  ]))) {
    addLeadingComment(followingNode, comment);
  }
}
function handleMixedInOuterAttributeComments({ precedingNode, enclosingNode, followingNode, comment }) {
  if (enclosingNode && hasOuterAttributes(enclosingNode) && end(comment) <= ownStart(enclosingNode)) {
    if (isPrettierIgnoreComment(comment) || isPrettierIgnoreAttribute(comment)) {
      setPrettierIgnoreTarget(enclosingNode, comment);
    }
    if (isEndOfLine(comment)) {
      if (shouldPrintOuterAttributesAbove(enclosingNode)) {
        addTrailingComment(precedingNode, comment);
      } else {
        addLeadingComment(followingNode || enclosingNode, comment);
      }
    } else {
      if (followingNode && end(followingNode) <= ownStart(enclosingNode)) {
        addLeadingComment(followingNode, comment);
      } else if (precedingNode && enclosingNode.loc.contains(precedingNode)) {
        addTrailingComment(precedingNode, comment);
      } else {
        addLeadingComment(enclosingNode, comment);
      }
    }
  }
}
function handleAttributeComments({ precedingNode, enclosingNode, followingNode, comment, ast }) {
  if (is_AttributeOrDocComment(comment)) {
    if (comment.inner && enclosingNode && is_FunctionDeclaration(enclosingNode) && (!followingNode || !is_StatementNode(followingNode)) && (!precedingNode || !is_StatementNode(precedingNode))) {
      if (enclosingNode.body) {
        if (canAttachCommentInLocArray(enclosingNode.body)) {
          addDanglingComment(enclosingNode, comment, "body" /* body */);
        } else {
          addLeadingComment(enclosingNode.body[0], comment);
        }
      } else {
        addLeadingComment(enclosingNode, comment);
      }
    } else {
      if (followingNode) {
        addLeadingComment(followingNode, comment);
      } else if (enclosingNode) {
        for (var key in DCM)
          if (key in enclosingNode) {
            addDanglingComment(enclosingNode, comment, key);
            return;
          }
      } else {
        addDanglingComment(ast, comment, "body" /* body */);
      }
    }
  }
}
function handleBadComments({ precedingNode, enclosingNode, followingNode, ast, comment }) {
  if (!enclosingNode) {
    if (followingNode) {
      addLeadingComment(followingNode, comment);
    } else if (precedingNode) {
      addTrailingComment(precedingNode, comment);
    } else {
      addDanglingComment(enclosingNode || ast, comment, "body" /* body */);
    }
  } else if (!precedingNode && !followingNode) {
    if (enclosingNode && enclosingNode !== ast) {
      addLeadingComment(enclosingNode, comment);
    } else {
      addDanglingComment(ast, comment, "body" /* body */);
    }
  }
}
function is_ABI_Comment({ precedingNode, enclosingNode, comment }) {
  return is_CommentOrDocComment(comment) && (precedingNode && is_ExternSpecifier(precedingNode) || enclosingNode && is_ExternSpecifier(enclosingNode));
}
function handleFlowControlComments({ precedingNode, enclosingNode, followingNode, comment }) {
  if (enclosingNode && is_FlowControlExpression(enclosingNode)) {
    if (!precedingNode && (isOwnLine(comment) || isEndOfLine(comment)) && !followingNode) {
      addLeadingComment(enclosingNode, comment);
    }
  }
}
function handleFunctionComments(ctx2) {
  var _a;
  const { precedingNode, enclosingNode, followingNode, comment } = ctx2;
  if (enclosingNode && is_FunctionNode(enclosingNode)) {
    if (is_FunctionDeclaration(enclosingNode) && (!is_ABI_Comment(ctx2) && comment.loc.isBefore(enclosingNode.generics || enclosingNode.id) || enclosingNode.generics && comment.loc.isBetween(enclosingNode.generics, enclosingNode.parameters))) {
      addLeadingComment(enclosingNode, comment);
    } else if (!enclosingNode.returnType && comment.loc.isBetween(
      enclosingNode.parameters,
      is_FunctionDeclaration(enclosingNode) ? enclosingNode.body : enclosingNode.expression
    )) {
      if (is_FunctionDeclaration(enclosingNode)) {
        addCommentToBlock(enclosingNode, comment);
      } else {
        addLeadingComment(enclosingNode.expression, comment);
      }
    } else if (precedingNode && enclosingNode.parameters.loc.contains(comment)) {
      if (precedingNode === getLastParameter(enclosingNode)) {
        addTrailingComment(precedingNode, comment);
      }
    } else if (followingNode && isStartOfLine(comment) && comment.loc.isAfter(enclosingNode.parameters) && (!is_FunctionDeclaration(enclosingNode) || !enclosingNode.whereBounds || comment.loc.isAfter(enclosingNode.whereBounds)) && (!enclosingNode.returnType || comment.loc.isAfter(enclosingNode.returnType)) && followingNode === (is_FunctionDeclaration(enclosingNode) ? (_a = enclosingNode.body) == null ? void 0 : _a[0] : enclosingNode.expression)) {
      addLeadingComment(followingNode, comment);
    }
  }
}
function handleMacroRuleComments(ctx2) {
  const { precedingNode, enclosingNode, followingNode, comment } = ctx2;
  if (enclosingNode && is_MacroRule(enclosingNode)) {
    if (enclosingNode.transform.loc.contains(comment)) {
      if (!precedingNode || !enclosingNode.transform.loc.contains(precedingNode)) {
        addLeadingComment(followingNode, comment);
      }
    } else if (enclosingNode.match.loc.contains(comment)) {
      if (!followingNode || !enclosingNode.match.loc.contains(followingNode)) {
        addTrailingComment(precedingNode, comment);
      }
    }
  }
}
function handleStatementComments(ctx2) {
  const { precedingNode, comment } = ctx2;
  if (isEndOfLine(comment) && precedingNode && (is_StatementNode(precedingNode) || precedingNode.loc.sliceText().endsWith(";"))) {
    addTrailingComment(precedingNode, comment);
  }
}
function addCommentToBlock(block, comment) {
  const body = getBodyOrCases(block);
  if (body.length > 0) {
    addLeadingComment(body[0], comment);
  } else {
    addDanglingComment(block, comment, "body" /* body */);
  }
}
function handleIfBlockExpressionComments(ctx2) {
  const { comment, enclosingNode } = ctx2;
  if (enclosingNode && is_IfBlockExpression(enclosingNode)) {
    const { condition, body, else: else_ } = enclosingNode;
    if (comment.loc.isBefore(condition)) {
      addLeadingComment(condition, comment);
    } else if (comment.loc.isBetween(condition, body)) {
      addTrailingComment(condition, comment);
    } else if (else_ && comment.loc.isBetween(body, else_)) {
      if (is_IfBlockExpression(else_)) {
        addLeadingComment(else_.condition, comment);
      } else {
        addCommentToBlock(else_, comment);
      }
    }
  }
}
function handleMemberExpressionComments({ comment, precedingNode, enclosingNode }) {
  if (enclosingNode && is_MemberAccessLike(enclosingNode)) {
    if (isStartOfLine(comment) || !precedingNode)
      addLeadingComment(enclosingNode, comment);
    else
      addTrailingComment(precedingNode, comment);
    return true;
  }
  return false;
}
function handleDanglingComments({ comment, enclosingNode }) {
  if (enclosingNode) {
    for (var key in DCM) {
      if (key in enclosingNode) {
        var arr = enclosingNode[key];
        if (is_LocArray(arr) && canAttachCommentInLocArray(arr) && arr.loc.contains(comment)) {
          addDanglingComment(enclosingNode, comment, key);
          return;
        }
      }
    }
  }
}
function canAttachCommentInLocArray(arr) {
  return arr.length === 0 || arr.every((node) => !canAttachComment(node));
}
function isOwnLine(comment) {
  return isStartOfLine(comment) && hasBreaklineAfter(comment);
}
function isStartOfLine(comment) {
  return comment.placement === "ownLine";
}
function isEndOfLine(comment) {
  return comment.placement === "endOfLine";
}
function isDangling(comment) {
  return !comment.leading && !comment.trailing;
}
function isLeading(comment) {
  return comment.leading && !comment.trailing;
}
function isTrailing(comment) {
  return !comment.leading && comment.trailing;
}
function print_comment(comment) {
  const doc2 = is_BlockCommentNode(comment) ? isIndentableBlockComment(comment.value) ? [
    (!handled(comment) || isTrailing(comment)) && !hasBreaklineBefore(comment) ? hardline : "",
    getCommentStart(comment),
    ...comment.value.split(/\n/g).map(
      (line2, i, a) => i === 0 ? [line2.trimEnd(), hardline] : !iLast(i, a) ? [" " + line2.trim(), hardline] : " " + line2.trimStart()
    ),
    "*/"
  ] : [
    getCommentStart(comment),
    join(literalline, comment.value.split(/\n/g)),
    "*/"
  ] : [getCommentStart(comment), comment.value.trimEnd()];
  return handled(comment) && isDangling(comment) ? [doc2, getPostLeadingComment(comment)] : doc2;
  function getCommentStart(comment2) {
    return is_Comment(comment2) ? is_BlockCommentKind(comment2) ? "/*" : "//" : is_BlockCommentKind(comment2) ? isInner(comment2) ? "/*!" : "/**" : isInner(comment2) ? "//!" : "///";
  }
  function isIndentableBlockComment(value) {
    const lines = `*${value}*`.split(/\n/g);
    return lines.length > 1 && lines.every((line2) => /^\s*\*/.test(line2));
  }
}
var printer = {
  [NodeType.MissingNode](print4, node) {
    return "";
  },
  [NodeType.SourceFile](print4, node) {
    return [
      print4.b("UTF8BOM", "\uFEFF"),
      print4("shebang"),
      print4("program")
    ];
  },
  [NodeType.Shebang](print4, node) {
    return [`#!${node.value}`, hardline];
  },
  [NodeType.Program](print4, node) {
    return printBodyOrCases(print4, node);
  },
  [NodeType.Snippet](print4, node) {
    exit.never();
  },
  [NodeType.Identifier](print4, node) {
    return node.name;
  },
  [NodeType.Index](print4, node) {
    return node.name;
  },
  [NodeType.LbIdentifier](print4, node) {
    return node.name;
  },
  [NodeType.McIdentifier](print4, node) {
    return node.name;
  },
  [NodeType.LtIdentifier](print4, node) {
    return node.name;
  },
  [NodeType.PunctuationToken](print4, node) {
    return node.token;
  },
  [NodeType.DelimGroup](print4, node) {
    return node.loc.getOwnText();
  },
  [NodeType.Literal](print4, node) {
    let { value } = node;
    if (is_LiteralNumberLike(node))
      value = printNumber(value);
    return hasSuffix(node) ? [value, print4("suffix")] : value;
  },
  [NodeType.ItemPath](print4, node) {
    return [print4("namespace"), "::", print4("segment")];
  },
  [NodeType.ExpressionPath](print4, node) {
    return [print4("namespace"), "::", print4("segment")];
  },
  [NodeType.TypePath](print4, node) {
    return [print4("namespace"), "::", print4("segment")];
  },
  [NodeType.Comment](print4, node) {
    return print_comment(node);
  },
  [NodeType.DocCommentAttribute](print4, node) {
    return print_comment(node);
  },
  [NodeType.Attribute](print4, node) {
    return [
      node.inner ? "#![" : "#[",
      isTransformed(node) ? [print4("segments"), printDanglingCommentsForInline(node)] : node.segments.loc.sliceText(1, -1).trim(),
      "]"
    ];
  },
  [NodeType.MacroInvocation](print4, node) {
    const hasCurlyBrackets = node.segments.dk === DelimKind["{}"];
    const delim = getDelimChars(node.segments);
    if (node.segments.length === 0) {
      return [print4("callee"), "!", hasCurlyBrackets ? " " : "", delim.left, printDanglingCommentsForInline(node), delim.right];
    }
    if (isTransformed(node)) {
      if (is_CallLikeMacroInvocation(node)) {
        return [print4("callee"), "!", printCallArguments(print4, node)];
      }
      if (is_BlockLikeMacroInvocation(node)) {
        return [print4("callee"), "!", " ", printBlockBody(print4, node)];
      }
    }
    let content = node.segments.loc.sliceText(1, -1);
    if (content.trim().length === 0) {
      content = "";
    } else if (!content.includes("\n")) {
      content = content.trim();
      if (hasCurlyBrackets)
        content = " " + content + " ";
    }
    return [print4("callee"), "!", hasCurlyBrackets ? " " : "", delim.left, content, delim.right];
  },
  [NodeType.MacroRulesDeclaration](print4, node) {
    return ["macro_rules! ", print4("id"), printMacroRules(print4, node)];
  },
  [NodeType.MacroRuleDeclaration](print4, node) {
    return [printRuleMatch(print4, node), " => ", printRuleTransform(print4, node), ";"];
  },
  [NodeType.MacroDeclaration](print4, node) {
    return [print4("pub"), "macro ", print4("id"), printMacroRules(print4, node)];
  },
  [NodeType.MacroInlineRuleDeclaration](print4, node) {
    return [printRuleMatch(print4, node), " ", printRuleTransform(print4, node)];
  },
  [NodeType.MacroGroup](print4, node) {
    return node.loc.getOwnText();
  },
  [NodeType.MacroParameterDeclaration](print4, node) {
    return [print4("id"), ":", print4("ty")];
  },
  [NodeType.PubSpecifier](print4, node) {
    if (!node.location)
      return "pub ";
    if (is_Identifier(node.location)) {
      switch (node.location.name) {
        case "crate":
          if (start(node) === start(node.location)) {
            return "crate ";
          } else {
            return ["pub(", print4("location"), ") "];
          }
        case "self":
        case "super":
          return ["pub(", print4("location"), ") "];
      }
    }
    return ["pub(in ", print4("location"), ") "];
  },
  [NodeType.ExternSpecifier](print4, node) {
    return ["extern ", f`${print4("abi")} `];
  },
  [NodeType.ExpressionStatement](print4, node) {
    return [print4("expression"), stmtNeedsSemi(node) ? ";" : ""];
  },
  [NodeType.UseStatement](print4, node) {
    return [print4("pub"), "use ", print4("import"), ";"];
  },
  [NodeType.DestructuredImport](print4, node) {
    if (node.specifiers.length === 0)
      return [print4("source"), "::{", printDanglingCommentsForInline(node, "specifiers" /* specifiers */), "}"];
    return [
      print4("source"),
      group([
        "::{",
        indent([line , join([",", line], print4("specifiers")), ifBreak(",")]),
        line ,
        "}"
      ])
    ];
  },
  [NodeType.AmbientImport](print4, node) {
    return f`${print4("source")}::*` || "*";
  },
  [NodeType.AnonymousImport](print4, node) {
    return [print4("source"), " as ", "_"];
  },
  [NodeType.NamedImport](print4, node) {
    return [print4("source"), f` as ${print4("local")}`];
  },
  [NodeType.ExternCrateStatement](print4, node) {
    return [print4("pub"), "extern crate ", print4("import"), ";"];
  },
  [NodeType.TypeAliasDeclaration](print4, node) {
    return [
      print4("pub"),
      "type",
      printAssignment(
        printGenerics_x_whereBounds(print4, node, printDeclarationTypeBounds(print4, node, ":")),
        " =",
        "typeExpression"
      ),
      ";"
    ];
  },
  [NodeType.LetVariableDeclaration](print4, node) {
    return [
      "let ",
      printAssignment(
        printAnnotatedPattern(print4, node),
        " =",
        "expression"
      ),
      f` else ${print4("else")}`,
      ";"
    ];
  },
  [NodeType.ConstVariableDeclaration](print4, node) {
    return [
      print4("pub"),
      "const ",
      printAssignment(
        printAnnotatedPattern(print4, node),
        " =",
        "expression"
      ),
      ";"
    ];
  },
  [NodeType.StaticVariableDeclaration](print4, node) {
    return [
      print4("pub"),
      "static ",
      printAssignment(
        printAnnotatedPattern(print4, node),
        " =",
        "expression"
      ),
      ";"
    ];
  },
  [NodeType.ModuleDeclaration](print4, node) {
    return [
      print4("pub"),
      print4.b("unsafe"),
      "mod ",
      print4("id"),
      printMaybeBlockBody(print4, node)
    ];
  },
  [NodeType.ExternBlockDeclaration](print4, node) {
    return [
      print4("pub"),
      print4.b("unsafe"),
      "extern ",
      f`${print4("abi")} `,
      printBlockBody(print4, node)
    ];
  },
  [NodeType.FunctionDeclaration](print4, node) {
    return [
      print4("pub"),
      print4.b("const"),
      print4.b("async"),
      print4.b("unsafe"),
      print4("extern"),
      "fn",
      printGenerics_x_whereBounds(print4, node, printParametersAndReturnType(node)),
      printMaybeBlockBody(print4, node)
    ];
  },
  [NodeType.FunctionSelfParameterDeclaration](print4, node) {
    return group([print4.b("ref", "&"), f`${print4("lt")} `, print4.b("mut"), "self", printTypeAnnotation(print4, node)]);
  },
  [NodeType.FunctionParameterDeclaration](print4, node) {
    return group(printAnnotatedPattern(print4, node));
  },
  [NodeType.FunctionSpread](print4, node) {
    return "...";
  },
  [NodeType.StructDeclaration](print4, node) {
    return [print4("pub"), "struct", printGenerics_x_whereBounds(print4, node, ""), printObject(print4, node)];
  },
  [NodeType.StructPropertyDeclaration](print4, node) {
    return [print4("pub"), print4("id"), printTypeAnnotation(print4, node)];
  },
  [NodeType.TupleStructDeclaration](print4, node) {
    return [print4("pub"), "struct", printGenerics_x_whereBounds(print4, node, printArrayLike(print4, node)), ";"];
  },
  [NodeType.TupleStructItemDeclaration](print4, node) {
    return [print4("pub"), print4("typeAnnotation")];
  },
  [NodeType.UnionDeclaration](print4, node) {
    return [print4("pub"), "union", printGenerics_x_whereBounds(print4, node, ""), printObject(print4, node)];
  },
  [NodeType.EnumDeclaration](print4, node) {
    return [print4("pub"), "enum", printGenerics_x_whereBounds(print4, node, ""), printEnumBody(print4, node)];
  },
  [NodeType.EnumMemberDeclaration](print4, node) {
    return [
      print4("pub"),
      printAssignment(
        print4("id"),
        " =",
        "value"
      )
    ];
  },
  [NodeType.EnumMemberTupleDeclaration](print4, node) {
    return [
      print4("pub"),
      printAssignment(
        [print4("id"), printArrayLike(print4, node)],
        " =",
        "value"
      )
    ];
  },
  [NodeType.EnumMemberStructDeclaration](print4, node) {
    return [
      print4("pub"),
      printAssignment(
        [print4("id"), printObject(print4, node)],
        " =",
        "value"
      )
    ];
  },
  [NodeType.TraitDeclaration](print4, node) {
    return [
      print4("pub"),
      print4.b("unsafe"),
      "trait",
      printGenerics_x_whereBounds(print4, node, printDeclarationTypeBounds(print4, node, ":")),
      adjustClause(node, printBlockBody(print4, node))
    ];
  },
  [NodeType.AutoTraitDeclaration](print4, node) {
    return [
      print4("pub"),
      print4.b("unsafe"),
      "auto trait ",
      print4("id"),
      " ",
      printBlockBody(print4, node)
    ];
  },
  [NodeType.TraitAliasDeclaration](print4, node) {
    return [
      print4("pub"),
      print4.b("unsafe"),
      "trait",
      printGenerics_x_whereBounds(print4, node, printDeclarationTypeBounds(print4, node, " =")),
      ";"
    ];
  },
  [NodeType.ImplDeclaration](print4, node) {
    return [
      print4("pub"),
      print4.b("unsafe"),
      "impl",
      printGenerics_x_whereBounds(print4, node, [print4.b("const"), printImplTraitForType(print4, node)]),
      adjustClause(node, printBlockBody(print4, node))
    ];
  },
  [NodeType.NegativeImplDeclaration](print4, node) {
    return [
      print4("pub"),
      "impl",
      printGenerics_x_whereBounds(print4, node, ["!", printImplTraitForType(print4, node)]),
      " ",
      printBlockBody(print4, node)
    ];
  },
  [NodeType.ExpressionTypeSelector](print4, node) {
    return group(["<", print4("typeTarget"), f` as ${print4("typeExpression")}`, ">"]);
  },
  [NodeType.ExpressionTypeCast](print4, node) {
    return [print4("typeCallee"), f`::${printTypeArguments(print4, node)}`];
  },
  [NodeType.ExpressionAsTypeCast](print4, node) {
    return [print4("expression"), " as ", print4("typeExpression")];
  },
  [NodeType.ReturnExpression](print4, node) {
    return ["return", printFlowControlExpression(print4, node)];
  },
  [NodeType.BreakExpression](print4, node) {
    return ["break", f` ${print4("label")}`, printFlowControlExpression(print4, node)];
  },
  [NodeType.ContinueExpression](print4, node) {
    return ["continue", f` ${print4("label")}`];
  },
  [NodeType.YieldExpression](print4, node) {
    return ["yield", printFlowControlExpression(print4, node)];
  },
  [NodeType.RangeLiteral](print4, node) {
    return [print4("lower"), "..", print4.b("last", "="), print4("upper")];
  },
  [NodeType.CallExpression](print4, node) {
    return printCallExpression(print4, node);
  },
  [NodeType.MemberExpression](print4, node) {
    return printMemberExpression(print4, node);
  },
  [NodeType.AwaitExpression](print4, node) {
    return [print4("expression"), ".await"];
  },
  [NodeType.UnwrapExpression](print4, node) {
    return [print4("expression"), "?"];
  },
  [NodeType.ParenthesizedExpression](print4, node) {
    exit.never();
    const shouldHug = !hasComment(node.expression) && (is_ArrayOrTupleLiteral(node.expression) || is_StructLiteral(node.expression));
    if (shouldHug)
      return ["(", print4("expression"), ")"];
    return group(["(", indent([softline, print4("expression")]), softline, ")"]);
  },
  [NodeType.MinusExpression](print4, node) {
    return printUnaryExpression("-");
  },
  [NodeType.NotExpression](print4, node) {
    return printUnaryExpression("!");
  },
  [NodeType.OrExpression](print4, node) {
    return printBinaryishExpression(print4, node);
  },
  [NodeType.AndExpression](print4, node) {
    return printBinaryishExpression(print4, node);
  },
  [NodeType.ReassignmentExpression](print4, node) {
    return printAssignment(print4("left"), " =", "right");
  },
  [NodeType.UnassignedExpression](print4, node) {
    return "_";
  },
  [NodeType.OperationExpression](print4, node) {
    return printBinaryishExpression(print4, node);
  },
  [NodeType.ReassignmentOperationExpression](print4, node) {
    return printAssignment(print4("left"), " " + node.kind, "right");
  },
  [NodeType.ComparisonExpression](print4, node) {
    return printBinaryishExpression(print4, node);
  },
  [NodeType.LetScrutinee](print4, node) {
    return ["let ", printAssignment(print4("pattern"), " =", "expression")];
  },
  [NodeType.ClosureFunctionExpression](print4, node) {
    return printArrowFunction(print4, node);
  },
  [NodeType.ClosureFunctionParameterDeclaration](print4, node) {
    return group(printAnnotatedPattern(print4, node));
  },
  [NodeType.BlockExpression](print4, node) {
    return [
      f`${print4("label")}: `,
      print4.b("const"),
      print4.b("async"),
      print4.b("move"),
      print4.b("unsafe"),
      printBlockBody(print4, node)
    ];
  },
  [NodeType.LoopBlockExpression](print4, node) {
    return [f`${print4("label")}: `, "loop ", printBlockBody(print4, node)];
  },
  [NodeType.WhileBlockExpression](print4, node) {
    return [f`${print4("label")}: `, "while ", printCondition(print4, node), printBlockBody(print4, node)];
  },
  [NodeType.ForInBlockExpression](print4, node) {
    return [f`${print4("label")}: `, "for ", print4("pattern"), " in ", print4("expression"), " ", printBlockBody(print4, node)];
  },
  [NodeType.IfBlockExpression](print4, node) {
    return [f`${print4("label")}: `, printIfBlock(print4, node)];
  },
  [NodeType.TryBlockExpression](print4, node) {
    return [f`${print4("label")}: `, "try ", printBlockBody(print4, node)];
  },
  [NodeType.MatchExpression](print4, node) {
    const id = Symbol("match");
    const expr = print4("expression");
    const needs_parens = pathCall(node, "expression", needsParens);
    let printed = [
      f`${print4("label")}: `,
      "match ",
      needs_parens ? expr : group([indent([softline, expr]), softline], { id }),
      needs_parens ? " " : !willBreak(expr) ? ifBreak("", " ", { groupId: id }) : "",
      printBlockBody(print4, node)
    ];
    const parent = getParentNode();
    if (is_ClosureFunctionExpression(parent) && parent.expression === node) {
      printed = parenthesize_if_break([indent([softline, printed]), softline]);
    }
    return printed;
  },
  [NodeType.MatchExpressionCase](print4, node) {
    return group([
      group(print4("pattern")),
      " ",
      printIfBlockCondition(print4, node),
      "=>",
      (is_BlockExpression(node.expression) || is_IfBlockExpression(node.expression)) && !hasComment(node.expression, 0, (comment) => getOptions().danglingAttributes.includes(comment)) ? [" ", print4("expression")] : group(indent([line, print4("expression")]))
    ]);
  },
  [NodeType.StructLiteral](print4, node) {
    return [print4("struct"), printObject(print4, node)];
  },
  [NodeType.StructLiteralPropertyShorthand](print4, node) {
    return print4("value");
  },
  [NodeType.StructLiteralProperty](print4, node) {
    return [print4("key"), ": ", print4("value")];
  },
  [NodeType.StructLiteralPropertySpread](print4, node) {
    return ["..", print4("expression")];
  },
  [NodeType.StructLiteralRestUnassigned](print4, node) {
    return "..";
  },
  [NodeType.ArrayLiteral](print4, node) {
    return printArrayLike(print4, node);
  },
  [NodeType.SizedArrayLiteral](print4, node) {
    return sg_duo`[${print4("initExpression")};${print4("sizeExpression")}]`;
  },
  [NodeType.TupleLiteral](print4, node) {
    return printArrayLike(print4, node);
  },
  [NodeType.ReferenceExpression](print4, node) {
    return printUnaryExpression(["&", print4.b("mut")]);
  },
  [NodeType.RawReferenceExpression](print4, node) {
    return printUnaryExpression(`&raw ${node.kind} `);
  },
  [NodeType.DereferenceExpression](print4, node) {
    return printUnaryExpression("*");
  },
  [NodeType.BoxExpression](print4, node) {
    return printUnaryExpression("box ");
  },
  [NodeType.UnionPattern](print4, node) {
    return printUnionPattern(print4, node);
  },
  [NodeType.ParenthesizedPattern](print4, node) {
    exit.never();
    return sg_single`(${print4("pattern")})`;
  },
  [NodeType.RestPattern](print4, node) {
    return "..";
  },
  [NodeType.WildcardPattern](print4, node) {
    return "_";
  },
  [NodeType.PatternVariableDeclaration](print4, node) {
    return [print4.b("ref"), print4.b("mut"), printAssignment(print4("id"), " @", "pattern")];
  },
  [NodeType.StructPattern](print4, node) {
    return [print4("struct"), printObject(print4, node)];
  },
  [NodeType.StructPatternPropertyDestructured](print4, node) {
    return [print4("key"), ": ", print4("pattern")];
  },
  [NodeType.StructPatternPropertyShorthand](print4, node) {
    return [print4.b("box"), print4.b("ref"), print4.b("mut"), print4("id")];
  },
  [NodeType.TuplePattern](print4, node) {
    return [print4("struct"), printArrayLike(print4, node)];
  },
  [NodeType.ArrayPattern](print4, node) {
    return printArrayLike(print4, node);
  },
  [NodeType.ReferencePattern](print4, node) {
    return ["&", print4.b("mut"), print4("pattern")];
  },
  [NodeType.BoxPattern](print4, node) {
    return ["box ", print4("pattern")];
  },
  [NodeType.MinusPattern](print4, node) {
    return ["-", print4("pattern")];
  },
  [NodeType.RangePattern](print4, node) {
    return [print4("lower"), "..", print4.b("last", "="), print4("upper")];
  },
  [NodeType.TypeCall](print4, node) {
    return [print4("typeCallee"), printTypeArguments(print4, node)];
  },
  [NodeType.TypeCallNamedArgument](print4, node) {
    return printAssignment(print4("target"), " =", "typeExpression");
  },
  [NodeType.TypeCallNamedBound](print4, node) {
    return [print4("typeTarget"), printTypeBounds(":", print4, node)];
  },
  [NodeType.LtElided](print4, node) {
    return "'_";
  },
  [NodeType.LtStatic](print4, node) {
    return "'static";
  },
  [NodeType.TypeNever](print4, node) {
    return "!";
  },
  [NodeType.TypeInferred](print4, node) {
    return "_";
  },
  [NodeType.GenericTypeParameterDeclaration](print4, node) {
    return printAssignment(
      [print4("id"), printTypeBounds(":", print4, node)],
      " =",
      "typeDefault"
    );
  },
  [NodeType.ConstTypeParameterDeclaration](print4, node) {
    return [
      "const ",
      printAssignment(
        [print4("id"), printTypeAnnotation(print4, node)],
        " =",
        "typeDefault"
      )
    ];
  },
  [NodeType.GenericLtParameterDeclaration](print4, node) {
    return [print4("id"), printLtBounds(":", print4, node)];
  },
  [NodeType.WhereTypeBoundDeclaration](print4, node) {
    return [printLtParameters(print4, node), print4("typeTarget"), printTypeBounds(":", print4, node)];
  },
  [NodeType.WhereLtBoundDeclaration](print4, node) {
    return [print4("ltTarget"), printLtBounds(":", print4, node)];
  },
  [NodeType.TypeTraitBound](print4, node) {
    return [print4.b("maybeConst", "~const "), print4.b("optional", "?"), printLtParameters(print4, node), print4("typeExpression")];
  },
  [NodeType.TypeDynBounds](print4, node) {
    return printTypeBounds("dyn", print4, node);
  },
  [NodeType.TypeImplBounds](print4, node) {
    return printTypeBounds("impl", print4, node);
  },
  [NodeType.TypeFnPointer](print4, node) {
    return [printLtParameters(print4, node), print4.b("unsafe"), print4("extern"), "fn", printParametersAndReturnType(node)];
  },
  [NodeType.TypeFnPointerParameter](print4, node) {
    return [f`${print4("id")}: `, print4("typeAnnotation")];
  },
  [NodeType.TypeFunction](print4, node) {
    return [print4("callee"), printParametersAndReturnType(node)];
  },
  [NodeType.TypeTuple](print4, node) {
    return printArrayLike(print4, node);
  },
  [NodeType.TypeSizedArray](print4, node) {
    return sg_duo`[${print4("typeExpression")};${print4("sizeExpression")}]`;
  },
  [NodeType.TypeSlice](print4, node) {
    if (isSimpleType(node))
      return ["[", print4("typeExpression"), "]"];
    return sg_single`[${print4("typeExpression")}]`;
  },
  [NodeType.TypeReference](print4, node) {
    return ["&", f`${print4("lt")} `, print4.b("mut"), print4("typeExpression")];
  },
  [NodeType.TypeDereferenceConst](print4, node) {
    return ["*const ", print4("typeExpression")];
  },
  [NodeType.TypeDereferenceMut](print4, node) {
    return ["*mut ", print4("typeExpression")];
  },
  [NodeType.TypeParenthesized](print4, node) {
    exit.never();
    return sg_single`(${print4("typeExpression")})`;
  }
};

// src/format/plugin.ts
function is_printing_macro() {
  return getContext().path.stack.some((node) => is_Node(node) && (is_MacroInvocation(node) || is_Attribute(node)));
}
function f(...args) {
  let cancel = false;
  const res = map_tagged_template(args, (doc2) => {
    cancel || (cancel = !doc2 || is_array(doc2) && doc2.length === 0);
    return doc2;
  });
  return cancel ? "" : res;
}
function sg_single(s, v_0) {
  return group([s[0], indent([softline, v_0]), softline, s[1]]);
}
function sg_duo(s, v_0, v_1) {
  return group([s[0], indent([softline, v_0, s[1], line, v_1]), softline, s[2]]);
}
var ctx;
var getNode = () => ctx.path.stack[ctx.path.stack.length - 1];
var stackIncludes = (x) => ctx.path.stack.includes(x);
var getContext = () => ctx;
var getOptions = () => ctx.options;
var getAllComments = () => ctx.options[Symbol_comments];
var getParentNode = (child) => {
  return ctx.path.getParentNode();
};
var getGrandParentNode = () => ctx.path.getParentNode(1);
var getPrintFn = (forNode) => {
  return print3;
};
var get = (property) => getNode()[property];
var has = (property) => !!get(property);
function pathCall(node, key, fn) {
  return ctx.path.call(() => fn(getNode()), key);
}
function pathCallEach(node, key, fn) {
  ctx.path.each((_, i) => fn(getNode(), i), key);
}
function pathCallAtParent(parent, fn) {
  return ctx.path.callParent(() => {
    return fn(parent);
  });
}
function pathCallParentOf(child, fn) {
  return ctx.path.callParent((p) => fn(getNode()));
}
function print3(property, args) {
  if (!property)
    return ctx.print(void 0, args);
  if (Array.isArray(property))
    return ctx.print(property, args);
  const value = get(property);
  return !!value ? Array.isArray(value) ? ctx.path.map(ctx.print, property) : ctx.print(property, args) : "";
}
((print4) => {
  function b(property, res = `${property} `) {
    return has(property) ? res : "";
  }
  print4.b = b;
  function map(property, mapItem) {
    return !has(property) ? [] : ctx.path.map(mapItem ? (p, i, a) => mapItem(a[i], i, a) : () => ctx.print(), property);
  }
  print4.map = map;
  function join2(property, sep, trailingSep = "") {
    return map_join(property, () => ctx.print(), sep, trailingSep);
  }
  print4.join = join2;
  function map_join(property, mapFn, sep, sepTrailing = "") {
    const sepFn = typeof sep === "function" ? sep : () => sep;
    return map(property, (v, i, a) => [
      mapFn(v, i, a),
      iLast(i, a) ? typeof sepTrailing === "function" ? sepTrailing(v) : sepTrailing : sepFn(v, a[i + 1], i === 0 ? void 0 : a[i - 1])
    ]);
  }
  print4.map_join = map_join;
})(print3 || (print3 = {}));
function genericPrint() {
  return withCheckContext(() => {
    const node = getNode();
    let printed = hasPrettierIgnore(node) ? node.loc.getOwnText() : printer[node.nodeType](print3, node);
    const inner_parens = needsInnerParens(node);
    if (inner_parens) {
      printed = group(["(", printed, ")"]);
    }
    if (hasAttributes(node)) {
      const print_above = shouldPrintOuterAttributesAbove(node);
      printed = [
        ...print3.join(
          "attributes",
          (attr) => print_above ? maybeEmptyLine(attr) : is_LineCommentNode(attr) || is_BlockCommentNode(attr) && hasBreaklineAfter(attr) ? hardline : " ",
          (attr) => print_above && is_DocCommentAttribute(attr) ? maybeEmptyLine(attr) : print_above || is_LineCommentNode(attr) || is_BlockCommentNode(attr) && hasBreaklineAfter(attr) ? hardline : " "
        ),
        printed
      ];
    }
    printed = withComments(
      node,
      printed,
      hasPrettierIgnore(node) || (is_Attribute(node) || is_MacroInvocation(node)) && !isTransformed(node) ? escapeComments(0, (comment) => node.loc.ownContains(comment)) : is_MacroRule(node) ? escapeComments(0, (comment) => node.transform.loc.contains(comment)) : is_UnionPattern(getParentNode() ?? { nodeType: 0 }) ? new Set(getComments(node, 0, (comment) => !isDangling(comment))) : void 0
    );
    if (!inner_parens && needsOuterSoftbreakParens(node)) {
      printed = [group(["(", indent([softline, printed]), softline, ")"])];
    }
    return printed;
  });
  function hasPrettierIgnore(node) {
    return node.prettierIgnore || hasComment(node, 64 /* PrettierIgnore */) || hasAttributes(node) && node.attributes.some(isPrettierIgnoreAttribute);
  }
}
function canAttachComment(n) {
  return !is_Comment(n) && !isNoopExpressionStatement(n) && !is_MissingNode(n) && !is_PunctuationToken(n);
}
var plugin = {
  languages: [
    {
      name: "Rust",
      aliases: ["rs"],
      parsers: ["jinx-rust"],
      extensions: [".rs", ".rs.in"],
      linguistLanguageId: 327,
      vscodeLanguageIds: ["rust"],
      tmScope: "source.rust",
      aceMode: "rust",
      codemirrorMode: "rust",
      codemirrorMimeType: "text/x-rustsrc"
    }
  ],
  parsers: {
    "jinx-rust": {
      astFormat: "jinx-rust",
      locStart: start,
      locEnd: end,
      parse(code, parsers2, options2) {
        ctx = { options: options2 };
        options2.rsParsedFile = rs.parseFile(options2.originalText = code, { filepath: options2.filepath });
        options2.actuallyMethodNodes = /* @__PURE__ */ new WeakSet();
        options2.danglingAttributes = [];
        options2.comments = [];
        transform_ast(options2);
        const comments = [];
        insertNodes(comments, options2.comments);
        insertNodes(comments, options2.danglingAttributes);
        options2.rsParsedFile.program.comments = comments;
        options2.commentSpans = new Map(comments.map((n) => [start(n), end(n)]));
        return options2.rsParsedFile.program;
      }
    }
  },
  printers: {
    "jinx-rust": {
      preprocess: (node) => node.loc.src,
      print(path, options2, print4, args) {
        if (path.stack.length === 1) {
          ctx = { path, options: options2, print: print4, args };
          try {
            const printed = genericPrint();
            return printed;
          } finally {
            ctx = void 0;
          }
        } else if (args || ctx.args) {
          const prev_args = ctx.args;
          try {
            ctx.args = args;
            return genericPrint();
          } finally {
            ctx.args = prev_args;
          }
        } else {
          return genericPrint();
        }
      },
      hasPrettierIgnore: () => false,
      willPrintOwnComments: () => true,
      isBlockComment: is_BlockCommentKind,
      canAttachComment,
      getCommentChildNodes,
      printComment: genericPrint,
      handleComments: {
        avoidAstMutation: true,
        ownLine: handleOwnLineComment,
        endOfLine: handleEndOfLineComment,
        remaining: handleRemainingComment
      }
    }
  },
  options: {},
  defaultOptions: {
    tabWidth: 4,
    printWidth: 100
  }
};

// src/index.ts
var src_default = plugin;
var languages = plugin.languages;
var parsers = plugin.parsers;
var printers = plugin.printers;
var options = plugin.options;
var defaultOptions = plugin.defaultOptions;
//!is_LetScrutinee(condition); //!is_LetScrutinee(getLeftMostCondition(condition));

export { src_default as default, defaultOptions, languages, options, parsers, printers };
